<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4SP - MUSIC</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLMD/CDh/f7T/y0ZgR70nQF/uJALzK3A5L3eN7/M7h6g2Gz1TqP+oV+6FvVz/yT/" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="../navigation.js"></script>

    <style>
        /* Base Styles */
        body {
            font-family: 'Geist', sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            min-height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            padding-bottom: 72px; 
            font-weight: 300; 
        }
        h1, h2, h3 {
            font-weight: 400; 
        }
        .font-semibold {
            font-weight: 500;
        }
        
        /* Squircle Border Radius Utility (for buttons) */
        .squircle {
            border-radius: 30%; /* Approximates a squircle shape */
        }
        .squircle-large {
            border-radius: 35%; 
        }


        /* 1. GLASSMORPHISM BUTTON STYLES (Applies to all elements with this class) */
        .glass-button {
            background-color: rgba(255, 255, 255, 0.05); /* Translucent white/grey */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.15s, border-color 0.15s, transform 0.15s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .glass-button:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        .glass-button-red {
            background-color: rgba(239, 68, 68, 0.2); /* Translucent Red */
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .glass-button-red:hover {
            background-color: rgba(239, 68, 68, 0.4);
            border-color: rgba(239, 68, 68, 0.5);
        }

        /* Bottom Player Bar */
        #bottom-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 72px;
            z-index: 50;
            transition: transform 0.3s ease-in-out;
            transform: translateY(100%); 
            background-color: rgba(0, 0, 0, 0.7); 
            backdrop-filter: blur(8px); 
            -webkit-backdrop-filter: blur(8px); 
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .player-visible {
            transform: translateY(0%) !important;
        }
        #youtube-player {
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
            width: 1px !important;
            height: 1px !important;
        }

        /* Modal Backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: rgba(31, 41, 55, 0.8); /* Translucent gray-800 */
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 1.5rem;
            max-width: 90%;
            width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Card Styles */
        .music-card {
            position: relative;
            background-color: #111827;
            border-radius: 0.75rem;
            overflow: hidden;
            aspect-ratio: 16 / 9; /* Ensures 16:9 ratio for cards */
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            cursor: pointer;
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }

        .music-card:hover {
            transform: scale(1.03);
            box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.5), 0 4px 6px -2px rgba(239, 68, 68, 0.2); 
        }
        
        .card-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: transform 0.3s ease-in-out;
            z-index: 1;
        }

        .card-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Stronger darkening effect */
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.6) 40%, rgba(0, 0, 0, 0.3) 60%, rgba(0, 0, 0, 0.1) 100%);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
            z-index: 2;
        }

        .card-details {
            display: flex;
            flex-direction: column;
            align-self: flex-start;
            /* Container for title/artist that needs the marquee effect */
            max-width: 100%; 
        }

        .card-actions {
            opacity: 0;
            display: flex;
            justify-content: flex-end; /* Align to the right for play button */
            align-items: center;
            transition: opacity 0.3s ease-in-out;
            align-self: flex-end; 
        }

        .music-card:hover .card-actions {
            opacity: 1;
        }
        
        .library-card {
            aspect-ratio: unset;
            height: 300px;
        }

        .library-card .card-actions {
            opacity: 1;
            margin-top: auto;
            align-self: stretch;
            justify-content: center; /* Center the buttons in library view */
        }

        /* MARQUEE TEXT STYLES */
        .marquee-container {
            overflow: hidden;
            white-space: nowrap;
            width: 100%; 
            position: relative; /* For the mask */
        }

        /* Fading mask effect on the marquee container */
        .marquee-container.active {
            /* Create a mask: transparent on the edges, solid white in the middle */
            -webkit-mask-image: linear-gradient(to right, 
                                rgba(0, 0, 0, 0) 0%, 
                                rgba(0, 0, 0, 1) 5%, 
                                rgba(0, 0, 0, 1) 95%, 
                                rgba(0, 0, 0, 0) 100%);
            mask-image: linear-gradient(to right, 
                                rgba(0, 0, 0, 0) 0%, 
                                rgba(0, 0, 0, 1) 5%, 
                                rgba(0, 0, 0, 1) 95%, 
                                rgba(0, 0, 0, 0) 100%);
        }

        .marquee-text {
            display: inline-block;
            transform: translateX(0); 
            animation-play-state: paused;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }
        
        /* Keyframes for the scrolling animation */
        @keyframes marquee {
            0% { transform: translateX(0); }
            /* Scroll distance is set via JS custom property */
            100% { transform: translateX(var(--marquee-scroll-distance)); } 
        }

        /* Apply marquee only when text overflows (JS will handle toggle) */
        .marquee-container.active .marquee-text {
            animation-name: marquee;
            animation-play-state: running;
        }
        
        .line-clamp-1, .line-clamp-2 {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .line-clamp-1 { -webkit-line-clamp: 1; }
        .line-clamp-2 { -webkit-line-clamp: 2; }

        /* Custom Colors for Status */
        .text-yellow-400-custom {
            color: rgb(252 214 0); /* yellow-400 */
        }
        .text-red-600-custom {
            color: rgb(220 38 38); /* red-600 */
        }
        
    </style>
</head>
<body>

    <main id="main-content" class="flex-grow p-4 md:p-8 pt-12">
        <h1 class="text-4xl font-semibold mb-6 tracking-tighter">Discover Music</h1>

        <div class="mb-8">
            <input type="text" id="search-input" placeholder="Search artists or songs..."
                   class="w-full p-3 rounded-lg bg-gray-900 border border-gray-700 focus:ring-red-500 focus:border-red-500 text-lg font-light">
            <div class="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 mt-2">
                <button id="search-button" class="flex-grow p-3 rounded-lg font-medium glass-button glass-button-red">Search YouTube Videos/Artists</button>
                <button id="add-url-button" class="flex-grow md:flex-grow-0 p-3 rounded-lg font-medium glass-button" onclick="promptAddUrl()">Add URL to Library</button>
            </div>
        </div>

        <div class="flex border-b border-gray-800 mb-6">
            <button data-view="home" class="nav-tab py-2 px-4 text-lg font-light border-b-2 border-red-600 text-red-500 glass-button-nav">Search Results</button>
            <button data-view="library" class="nav-tab py-2 px-4 text-lg font-light border-b-2 border-transparent hover:border-gray-600 text-gray-400 ml-4 glass-button-nav">My Library</button>
        </div>
        
        <div id="channel-banner" class="bg-gray-800/70 p-3 rounded-lg mb-6 hidden items-center justify-between glass-button">
            <p id="channel-banner-text" class="text-gray-200 font-light"></p>
            <button id="go-back-btn" class="py-1 px-3 text-xs rounded-lg text-gray-300 font-light glass-button">
                <i class="fa-solid fa-arrow-left mr-1"></i> Go Back
            </button>
        </div>

        <section id="music-view" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 xl:grid-cols-5 gap-6">
            <p id="initial-message" class="col-span-full text-gray-500 font-light">Securely fetching API key and checking authentication...</p>
        </section>
        
    </main>

    <div id="youtube-player"></div>

    <footer id="bottom-player" class="flex items-center justify-between px-4 py-2">
        <div id="player-info" class="flex items-center space-x-4 flex-grow min-w-0"> 
            <img id="current-thumbnail" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236B7280'%3E%3Cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z'/%3E%3C/svg%3E" alt="Album Art" class="w-12 h-12 rounded-lg object-cover bg-gray-700 flex-shrink-0">
            
            <div class="flex-grow min-w-0 pr-4 max-w-xs md:max-w-md"> 
                <div id="current-title-container" class="text-sm font-medium marquee-container">
                    <div id="current-title" class="marquee-text">No song playing</div>
                </div>
                <div id="current-artist-container" class="text-xs text-gray-400 font-light marquee-container mt-0.5">
                    <div id="current-artist" class="marquee-text"></div>
                </div>
            </div>
        </div>

        <div class="flex items-center space-x-6">
            <button id="skip-back" class="text-gray-400 hover:text-white transition duration-150 disabled:opacity-50 glass-button p-3 squircle">
                <i class="fa-solid fa-backward-step fa-lg"></i>
            </button>
            <button id="play-pause" class="text-white hover:text-red-500 transition duration-150 w-14 h-14 flex items-center justify-center squircle-large disabled:opacity-50 glass-button glass-button-red" disabled>
                <i id="play-icon" class="fa-solid fa-play fa-xl"></i> 
            </button>
            <button id="skip-next" class="text-gray-400 hover:text-white transition duration-150 disabled:opacity-50 glass-button p-3 squircle">
                <i class="fa-solid fa-forward-step fa-lg"></i>
            </button>
        </div>

        <button id="add-to-library-btn" class="p-2 ml-4 text-gray-400 hover:text-red-400 transition duration-150 hidden glass-button squircle" title="Add to Library">
            <i id="add-to-library-icon" class="fa-solid fa-book-bookmark fa-xl"></i>
        </button>
    </footer>
    
    <div id="edit-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2 class="text-xl font-semibold mb-4 text-white">Edit Song Details</h2>
            <div class="mb-4">
                <label for="edit-title" class="block text-sm font-light text-gray-400 mb-1">Title</label>
                <input type="text" id="edit-title" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-red-500 focus:border-red-500 font-light">
            </div>
            <div class="mb-6">
                <label for="edit-artist" class="block text-sm font-light text-gray-400 mb-1">Artist</label>
                <input type="text" id="edit-artist" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-red-500 focus:border-red-500 font-light">
            </div>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="py-2 px-4 rounded-lg font-medium glass-button">Cancel</button>
                <button id="modal-save-btn" class="py-2 px-4 rounded-lg font-medium glass-button glass-button-red">Save Changes</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        import { firebaseConfig } from '../firebase-config.js';

        // --- GLOBAL STATE & INITIALIZATION ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const redirectPath = '../index.html';
        let youtubeApiKey = null;
        let ytPlayer = null; 
        let isPlayerReady = false;
        
        // Player state
        let currentPlaylist = [];
        let currentPlaylistIndex = -1;
        let isPlayingFromLibrary = false;
        let currentChannelTitle = null; 
        let searchHistory = []; 
        
        // New Player Status State (Restored)
        let adPollingInterval = null;
        let adIsPlaying = false;
        let playerHasError = false;


        // Local Library Storage
        const LOCAL_STORAGE_KEY = 'musicflow_library';
        let userLibrary = loadLibrary();

        const ui = {
            musicView: document.getElementById('music-view'),
            bottomPlayer: document.getElementById('bottom-player'),
            currentTitleContainer: document.getElementById('current-title-container'),
            currentArtistContainer: document.getElementById('current-artist-container'),
            currentTitle: document.getElementById('current-title'),
            currentArtist: document.getElementById('current-artist'),
            currentThumbnail: document.getElementById('current-thumbnail'),
            playPauseBtn: document.getElementById('play-pause'),
            playIcon: document.getElementById('play-icon'),
            skipBackBtn: document.getElementById('skip-back'),
            skipNextBtn: document.getElementById('skip-next'),
            searchInput: document.getElementById('search-input'),
            searchButton: document.getElementById('search-button'),
            addToLibraryBtn: document.getElementById('add-to-library-btn'),
            addToLibraryIcon: document.getElementById('add-to-library-icon'), 
            navTabs: document.querySelectorAll('.nav-tab'),
            channelBanner: document.getElementById('channel-banner'),
            channelBannerText: document.getElementById('channel-banner-text'),
            goBackButton: document.getElementById('go-back-btn'), 
            
            // Edit Modal elements
            editModal: document.getElementById('edit-modal'),
            editTitleInput: document.getElementById('edit-title'),
            editArtistInput: document.getElementById('edit-artist'),
            modalSaveBtn: document.getElementById('modal-save-btn'),
            modalCancelBtn: document.getElementById('modal-cancel-btn'),
        };

        // --- UTILITY FUNCTIONS ---
        
        /**
         * Checks if the text inside the element overflows its container and toggles the marquee class.
         */
        function updateMarquee(textElement, containerElement) {
            // Use an existing original text data attribute, or save the current text as original
            const originalText = textElement.dataset.originalText || textElement.textContent;
            textElement.dataset.originalText = originalText;
            
            // 1. Reset to original text for accurate measurement
            textElement.textContent = originalText;
            
            // 2. Temporarily set display to inline-block and measure the true content width
            textElement.style.display = 'inline-block';
            const textWidth = textElement.scrollWidth; 
            textElement.style.display = ''; // Reset display style

            const containerWidth = containerElement.offsetWidth;
            const isOverflowing = textWidth > containerWidth;

            if (isOverflowing) {
                containerElement.classList.add('active');
                
                // 3. Calculate scroll distance (full width of the original text + a gap)
                const gap = 30; // Gap between repetitions
                const scrollDistance = textWidth + gap; 
                
                // 4. Set the CSS variable for the marquee animation
                containerElement.style.setProperty('--marquee-scroll-distance', `-${scrollDistance}px`);
                
                // 5. Repeat the content for the seamless loop animation
                textElement.innerHTML = originalText + '&nbsp;'.repeat(gap / 6) + originalText;
                
                // 6. Adjust animation duration based on content length for consistent speed
                const speed = 40; // pixels per second (slightly slower for readability)
                const duration = scrollDistance / speed; // seconds
                textElement.style.animationDuration = `${duration}s`;
                
            } else {
                containerElement.classList.remove('active');
                // Ensure text element only has original text and no animation class/style
                textElement.textContent = originalText;
                textElement.style.animationDuration = '0s'; // Stop the animation
                textElement.style.transform = 'translateX(0)';
            }
        }
        
        /**
         * Helper to disable marquee/animations and restore the content container to a static state. (Restored)
         */
        function stopMarquee(textElement, containerElement) {
            containerElement.classList.remove('active');
            // Ensure the displayed text is just the original text (or the manually set error/ad message)
            textElement.textContent = textElement.textContent; 
            textElement.style.animationDuration = '0s'; 
            textElement.style.transform = 'translateX(0)';
        }

        /**
         * Asynchronously filters text for explicit content using the Purgomalum API.
         */
        async function filterExplicitText(text) {
            if (!text) return '';
            try {
                for (let attempt = 0; attempt < 3; attempt++) {
                    const url = `https://www.purgomalum.com/service/plain?text=${encodeURIComponent(text)}`;
                    const response = await fetch(url);

                    if (response.ok) {
                        return await response.text();
                    }
                    if (response.status === 429 && attempt < 2) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                        continue;
                    }
                    console.warn(`Purgomalum filter failed (Status ${response.status}). Returning original text.`);
                    return text;
                }
                return text;
            } catch (e) {
                console.error("Error during Purgomalum API call:", e); 
                return text;
            }
        }

        /**
         * Decodes HTML entities (like &amp; or &quot;) into their character equivalents.
         */
        function decodeHtmlEntities(text) {
            const temp = document.createElement('textarea');
            temp.innerHTML = text;
            return temp.value;
        }

        // --- FIREBASE AND AUTHENTICATION ---
        async function fetchApiKey() {
            try {
                const apiDocRef = doc(db, 'secrets', 'apis');
                const docSnap = await getDoc(apiDocRef);

                if (docSnap.exists() && docSnap.data().youtubeAPI) {
                    youtubeApiKey = docSnap.data().youtubeAPI;
                    return true;
                } else {
                    console.error("Firebase Error: No 'youtubeAPI' field found in 'secrets/apis' document.");
                    return false;
                }
            } catch (error) {
                console.error("Firestore Error: Error fetching API key.", error);
                return false;
            }
        }

        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                window.location.replace(redirectPath);
            } else {
                const keyFetched = await fetchApiKey();

                if (keyFetched) {
                    ui.musicView.innerHTML = '<p class="col-span-full text-gray-500 font-light">Enter a query above and click "Search" to find music videos/artists.</p>';
                    loadYouTubeIframeAPI();
                    attachEventListeners();
                    renderLibrary(); 
                } else {
                    ui.musicView.innerHTML = '<p class="col-span-full text-xl text-red-500 font-light">Initialization Error: Could not load YouTube API Key securely. See console for details.</p>';
                }
            }
        });


        // --- YOUTUBE API INTEGRATION (Audio-Only Focus) ---
        function loadYouTubeIframeAPI() {
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }

        window.onYouTubeIframeAPIReady = function() {
            ytPlayer = new YT.Player('youtube-player', {
                height: '100%',
                width: '100%',
                videoId: '', 
                playerVars: {
                    'controls': 0, 
                    'disablekb': 1,
                    'modestbranding': 1,
                    'rel': 0,
                    'showinfo': 0,
                    'fs': 0,
                    'playsinline': 1,
                    'autoplay': 0
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError // ADDED: Error handler (Restored)
                }
            });
        }

        function onPlayerReady(event) {
            isPlayerReady = true;
            ui.playPauseBtn.disabled = false;
            ui.skipBackBtn.disabled = false;
            ui.skipNextBtn.disabled = false;
            
            // ADDED: Start Ad Polling as soon as the player is ready (Restored)
            if (!adPollingInterval) {
                // YT.AdState enum is implicitly available after player is ready
                adPollingInterval = setInterval(handleAdStatus, 1000); // Check every second
            }
        }
        
        // ADDED: Function to handle YouTube player errors (Restored)
        function onPlayerError(event) {
            playerHasError = true;
            
            const errorCode = event.data;
            console.error(`Youtubeer Error: ${errorCode}. Attempting to skip.`);

            // 1. Stop Marquee/Animation
            stopMarquee(ui.currentTitle, ui.currentTitleContainer);
            stopMarquee(ui.currentArtist, ui.currentArtistContainer);
            
            // 2. Update UI as requested
            ui.currentThumbnail.src = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23DC2626\'%3E%3Cpath d=\'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\'/%3E%3C/svg%3E'; // Error Icon (red)
            ui.currentTitle.textContent = "Error: Cannot Play Video"; // Replaces song title
            ui.currentTitle.classList.add('text-red-600-custom'); // Custom red color
            ui.currentArtist.textContent = `Error Code: ${errorCode}. Skipping...`; // Replaces artist name
            ui.currentArtist.style.color = 'rgb(255 255 255 / 0.7)'; // Keep white/light gray color

            // 3. Immediately skip to the next track
            setTimeout(() => {
                skipNext();
                playerHasError = false; // Reset state after skipping
                // Colors will be reset in handleAdStatus/updatePlayerInfoUI
                ui.currentTitle.classList.remove('text-red-600-custom'); 
            }, 3000); // 3-second delay to show the error
        }


        function onPlayerStateChange(event) {
            const state = event.data;
            
            if (state === YT.PlayerState.PLAYING) {
                ui.playIcon.className = 'fa-solid fa-pause fa-xl'; 
            } else {
                ui.playIcon.className = 'fa-solid fa-play fa-xl'; 
            }
            
            if (state === YT.PlayerState.ENDED) {
                // Implement playlist looping (Restored)
                const nextIndex = currentPlaylistIndex + 1;
                if (nextIndex < currentPlaylist.length) {
                    skipNext();
                } else {
                    // Restart the playlist from the beginning (index 0)
                    startPlaylist(currentPlaylist, 0, isPlayingFromLibrary);
                }
            }
        }
        
        // ADDED: Function to handle ad status polling (Restored)
        function handleAdStatus() {
            // This is the line that was throwing the error: ytPlayer.getAdState is not a function
            // The fix is ensuring ytPlayer is ready and using YT.AdState.
            if (!isPlayerReady || playerHasError || !window.YT) return; 

            // YT.AdState is accessible after the API loads
            // If getAdState() fails, it's likely YT object isn't fully ready or an iframe restriction.
            try {
                 const adState = ytPlayer.getAdState();
                 // Check against the AdState enum which should be available
                 const newAdIsPlaying = adState === window.YT.AdState.AD_PLAYING || adState === window.YT.AdState.AD_PAUSED;
                 
                 if (newAdIsPlaying !== adIsPlaying) {
                     adIsPlaying = newAdIsPlaying;

                     if (adIsPlaying) {
                         // Ad started playing
                         stopMarquee(ui.currentTitle, ui.currentTitleContainer);
                         stopMarquee(ui.currentArtist, ui.currentArtistContainer);

                         // Update UI to show ad status
                         ui.currentTitle.textContent = "Ad Playing";
                         ui.currentTitle.classList.add('text-yellow-400-custom');
                         ui.currentArtist.textContent = "Thank you for supporting the creator!";
                         ui.currentArtist.style.color = 'rgb(255 255 255 / 0.7)'; 
                         ui.currentThumbnail.src = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23FBBF24\'%3E%3Cpath d=\'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z\'/%3E%3C/svg%3E'; // Ad icon (yellow info)
                         
                     } else {
                         // Ad stopped playing
                         // Restore text colors and information
                         ui.currentTitle.classList.remove('text-yellow-400-custom'); 
                         ui.currentArtist.style.color = ''; // Reset to default gray-400

                         const currentSong = currentPlaylist[currentPlaylistIndex];
                         if (currentSong) {
                             // Restore song info and re-enable marquee
                             updatePlayerInfoUI(currentSong);
                         }
                     }
                 }
            } catch (e) {
                 // Suppress console spam if getAdState is temporarily unavailable during loading.
                 // console.warn('Ad state check skipped or failed:', e.message); 
            }
        }


        /**
         * Search for YouTube videos/channels and manages search history.
         */
        async function performSearch(query, isBack = false) {
            if (!youtubeApiKey || !query.trim()) {
                ui.musicView.innerHTML = '<p class="col-span-full text-xl text-gray-400 font-light">Please enter a valid search query.</p>';
                currentChannelTitle = null;
                ui.channelBanner.classList.add('hidden');
                return;
            }

            ui.musicView.innerHTML = '<p class-span-full text-xl text-gray-400 font-light">Searching YouTube for music...</p>';
            
            // History Management
            if (!isBack && query.trim() !== searchHistory[searchHistory.length - 1]) {
                searchHistory.push(query.trim());
            }

            const searchUrl = new URL('https://www.googleapis.com/youtube/v3/search');
            searchUrl.searchParams.set('part', 'snippet');
            searchUrl.searchParams.set('q', query);
            
            searchUrl.searchParams.set('type', 'video,channel'); 
            searchUrl.searchParams.set('maxResults', '20');
            searchUrl.searchParams.set('key', youtubeApiKey);
            
            // Update channel banner based on the context of the search
            if (currentChannelTitle && query === currentChannelTitle) {
                ui.channelBanner.classList.remove('hidden');
                ui.channelBanner.style.display = 'flex'; // Ensure flex layout for button
                ui.channelBannerText.textContent = `Viewing videos for channel: ${currentChannelTitle}`;
                // Only show back button if there is history to go back to (more than one item)
                ui.goBackButton.classList.toggle('hidden', searchHistory.length <= 1); 
            } else {
                currentChannelTitle = null;
                ui.channelBanner.classList.add('hidden');
            }

            try {
                const response = await fetch(searchUrl.toString());
                
                if (!response.ok) {
                    const errorData = await response.json();
                    let errorMessage = `Status ${response.status}. Message: ${errorData.error.message || 'Unknown error.'}`;
                    ui.musicView.innerHTML = `<p class-span-full text-xl text-red-500 font-light">Search Failed (${errorMessage})</p>`;
                    return;
                }
                
                const data = await response.json();
                
                if (data.items && data.items.length > 0) {
                    currentPlaylist = data.items.filter(item => item.id.kind === 'youtube#video').map(item => ({
                        videoId: item.id.videoId,
                        title: item.snippet.title,
                        artist: item.snippet.channelTitle,
                        thumbnail: item.snippet.thumbnails.medium.url,
                    }));
                    renderSearchResults(data.items);
                } else {
                    ui.musicView.innerHTML = `<p class="col-span-full text-xl text-gray-400 font-light">No music videos or artists found for "${query}".</p>`;
                }
            } catch (error) {
                console.error("Network or Fetch Error during search:", error);
                ui.musicView.innerHTML = '<p class="col-span-full text-xl text-red-500 font-light">Search failed due to a network or general error.</p>';
            }
        }
        
        /**
         * Reverts to the previous search query in the history stack.
         */
        function goBackToLastSearch() {
            if (searchHistory.length > 1) {
                searchHistory.pop(); // Remove the current channel/search query
                const previousQuery = searchHistory[searchHistory.length - 1]; 
                
                ui.searchInput.value = previousQuery;
                currentChannelTitle = null;
                performSearch(previousQuery, true); 
                
            } else if (searchHistory.length === 1) {
                 searchHistory = [];
                 currentChannelTitle = null;
                 ui.channelBanner.classList.add('hidden');
                 ui.musicView.innerHTML = '<p class="col-span-full text-gray-500 font-light">Enter a query above and click "Search" to find music videos/artists.</p>';
            }
        }

        async function renderSearchResults(items) {
            ui.musicView.innerHTML = ''; 
            
            for (const item of items) {
                const isVideo = item.id.kind === 'youtube#video';
                const id = isVideo ? item.id.videoId : item.id.channelId;
                
                let title = decodeHtmlEntities(item.snippet.title);
                let channelTitle = decodeHtmlEntities(item.snippet.channelTitle);
                
                // Content Filtering
                title = await filterExplicitText(title);
                channelTitle = await filterExplicitText(channelTitle);

                const thumbnail = item.snippet.thumbnails.medium.url;
                const videoIndex = currentPlaylist.findIndex(song => song.videoId === id);

                const card = document.createElement('div');
                card.className = 'music-card'; 
                card.dataset.id = id;
                card.dataset.type = isVideo ? 'video' : 'artist';
                
                // --- CARD STRUCTURE ---
                card.innerHTML = `
                    <div class="card-background" style="background-image: url('${thumbnail}');"></div>
                    
                    <div class="card-overlay">
                        <div class="card-details">
                            <div class="text-xl font-medium mb-1 marquee-container card-title-container">
                                <div class="marquee-text card-title" data-original-text="${item.snippet.title}">${title}</div>
                            </div>
                            <div class="text-sm text-gray-300 font-light marquee-container card-artist-container">
                                <div class="marquee-text card-artist" data-original-text="${item.snippet.channelTitle}">${channelTitle}</div>
                            </div>
                        </div>
                        
                        <div class="card-actions">
                            ${isVideo 
                                ? `<button data-index="${videoIndex}" class="play-video-btn p-3 text-white text-lg font-semibold shadow-xl glass-button glass-button-red squircle-large">
                                    <i class="fa-solid fa-play"></i>
                                   </button>` 
                                : `<button class="view-artist-btn w-full p-2 rounded-lg text-sm font-semibold glass-button">
                                     <i class="fa-solid fa-users mr-2"></i> View Channel
                                   </button>`
                            }
                        </div>
                    </div>
                `;
                // --- END CARD STRUCTURE ---
                
                if (isVideo) {
                    // Play Audio via clicking the card
                    card.addEventListener('click', () => {
                        startPlaylist(currentPlaylist, videoIndex, false);
                    });
                    // Play Audio via the button
                    card.querySelector('.play-video-btn').addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        startPlaylist(currentPlaylist, videoIndex, false);
                    });

                } else {
                    const artistClickHandler = (e) => {
                        e.stopPropagation();
                        currentChannelTitle = channelTitle;
                        ui.searchInput.value = channelTitle;
                        performSearch(channelTitle);
                    };
                    card.querySelector('.view-artist-btn').addEventListener('click', artistClickHandler);
                    card.addEventListener('click', artistClickHandler);
                }

                ui.musicView.appendChild(card);
                
                // Check and apply marquee animation to card text
                const titleEl = card.querySelector('.card-title');
                const titleContainer = card.querySelector('.card-title-container');
                const artistEl = card.querySelector('.card-artist');
                const artistContainer = card.querySelector('.card-artist-container');
                
                // Delay slightly to ensure layout rendering is complete
                setTimeout(() => {
                    updateMarquee(titleEl, titleContainer);
                    updateMarquee(artistEl, artistContainer);
                }, 100); 
            }
        }


        // --- PLAYER CONTROLS & LOGIC ---

        function isSongInLibrary(videoId) {
            return userLibrary.some(song => song.videoId === videoId);
        }

        function updateLibraryIcon(videoId) {
            const btn = ui.addToLibraryBtn;
            const icon = ui.addToLibraryIcon;

            if (!videoId) {
                btn.classList.add('hidden');
                return;
            }
            btn.classList.remove('hidden');

            if (isSongInLibrary(videoId)) {
                icon.classList.remove('text-gray-400');
                icon.classList.add('text-red-500');
                btn.title = "Song is in your library (Click to remove)";
                btn.dataset.inLibrary = 'true';
            } else {
                icon.classList.remove('text-red-500');
                icon.classList.add('text-gray-400');
                btn.title = "Add to Library";
                btn.dataset.inLibrary = 'false';
            }
        }
        
        // ADDED: New helper function to update UI without restarting the player (Restored)
        async function updatePlayerInfoUI(song) {
            if (!song) return;
            
            // Clear any lingering error/ad styling
            ui.currentTitle.classList.remove('text-red-600-custom');
            ui.currentTitle.classList.remove('text-yellow-400-custom');
            ui.currentArtist.style.color = ''; // Reset to default gray-400

            const decodedTitle = decodeHtmlEntities(song.title);
            const decodedArtist = decodeHtmlEntities(song.artist);
            
            const filteredTitle = await filterExplicitText(decodedTitle);
            const filteredArtist = await filterExplicitText(decodedArtist);

            // Update UI with the clean, original text
            ui.currentTitle.dataset.originalText = decodedTitle;
            ui.currentArtist.dataset.originalText = decodedArtist;
            ui.currentTitle.textContent = filteredTitle;
            ui.currentArtist.textContent = filteredArtist;
            ui.currentThumbnail.src = song.thumbnail;
            
            // Marquee Update
            setTimeout(() => {
                updateMarquee(ui.currentTitle, ui.currentTitleContainer);
                updateMarquee(ui.currentArtist, ui.currentArtistContainer);
            }, 50);
            
            updateLibraryIcon(song.videoId);
        }


        async function startPlaylist(playlist, index, fromLibrary = false) {
            if (!isPlayerReady || playlist.length === 0 || index < 0 || index >= playlist.length) return;
            
            playerHasError = false; // Reset error state on new song start
            
            currentPlaylist = playlist;
            currentPlaylistIndex = index;
            isPlayingFromLibrary = fromLibrary;
            
            const currentSong = currentPlaylist[currentPlaylistIndex];
            
            ytPlayer.loadVideoById(currentSong.videoId);
            
            await updatePlayerInfoUI(currentSong); // Use the new helper function to update UI

            ui.bottomPlayer.classList.add('player-visible');

            // Set data attributes for library management
            ui.addToLibraryBtn.dataset.videoId = currentSong.videoId;
            ui.addToLibraryBtn.dataset.title = currentSong.title; 
            ui.addToLibraryBtn.dataset.artist = currentSong.artist;
            ui.addToLibraryBtn.dataset.thumbnail = currentSong.thumbnail;
            
            updateLibraryIcon(currentSong.videoId);
            
            // Start ad polling if not running (already started in onPlayerReady, but safe to check)
            if (!adPollingInterval) {
                 adPollingInterval = setInterval(handleAdStatus, 1000); 
            }
        }

        function togglePlayPause() {
            if (!ytPlayer || currentPlaylistIndex === -1) return;
            const state = ytPlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                ytPlayer.pauseVideo();
            } else {
                ytPlayer.playVideo();
            }
        }

        function skipNext() {
            if (currentPlaylistIndex === -1) return;
            const nextIndex = currentPlaylistIndex + 1;
            
            if (nextIndex < currentPlaylist.length) {
                startPlaylist(currentPlaylist, nextIndex, isPlayingFromLibrary);
            } else {
                // If it's the last song, restart the playlist from the beginning (index 0)
                startPlaylist(currentPlaylist, 0, isPlayingFromLibrary);
            }
        }

        function skipBack() {
            if (currentPlaylistIndex === -1) return;
            
            // If the song is already a few seconds in, restart the song, otherwise go to previous
            if (ytPlayer.getCurrentTime() > 3) { 
                ytPlayer.seekTo(0, true);
                return;
            }

            const prevIndex = currentPlaylistIndex - 1;
            
            if (prevIndex >= 0) {
                startPlaylist(currentPlaylist, prevIndex, isPlayingFromLibrary);
            } else {
                // If it's the first song and skip back is pressed, go to the last song
                startPlaylist(currentPlaylist, currentPlaylist.length - 1, isPlayingFromLibrary);
            }
        }

        // --- LOCAL LIBRARY & PLAYLIST MANAGEMENT ---

        function loadLibrary() {
            try {
                const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error("Error loading library from localStorage:", e);
                return [];
            }
        }

        function saveLibrary() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(userLibrary));
            } catch (e) {
                console.error("Error saving library to localStorage:", e);
            }
        }
        
        function addToLibrary(songData) {
            const videoId = songData.videoId;
            if (isSongInLibrary(videoId)) {
                console.log(`"${songData.title}" is already in your library!`);
                return;
            }

            const newSong = {
                videoId: videoId,
                title: songData.title, 
                artist: songData.artist,
                thumbnail: songData.thumbnail,
                added: new Date().toISOString()
            };
            
            userLibrary.unshift(newSong); // Add to the start for better visibility
            saveLibrary();
            console.log(`"${newSong.title}" added to your library!`);
            
            updateLibraryIcon(videoId);
            if (document.querySelector('.nav-tab[data-view="library"]').classList.contains('border-red-600')) {
                renderLibrary();
            }
        }

        function removeFromLibrary(videoId) {
            if (window.confirm("Are you sure you want to remove this song from your library?")) {
                userLibrary = userLibrary.filter(song => song.videoId !== videoId);
                saveLibrary();
                console.log("Song removed from library.");
                
                // If the removed song was the currently playing one, update the icon status
                if (ui.addToLibraryBtn.dataset.videoId === videoId) {
                    updateLibraryIcon(videoId); 
                }

                if (document.querySelector('.nav-tab[data-view="library"]').classList.contains('border-red-600')) {
                    renderLibrary();
                }
            }
        }

        function showEditModal(index) {
            const song = userLibrary[index];
            if (!song) return;

            ui.editTitleInput.value = song.title;
            ui.editArtistInput.value = song.artist;
            ui.editModal.dataset.editIndex = index;

            ui.editModal.style.display = 'flex';
        }

        function saveNameEdit() {
            const index = parseInt(ui.editModal.dataset.editIndex);
            if (isNaN(index) || index < 0 || index >= userLibrary.length) return;

            const newTitle = ui.editTitleInput.value.trim();
            const newArtist = ui.editArtistInput.value.trim();

            if (newTitle && newArtist) {
                userLibrary[index].title = newTitle;
                userLibrary[index].artist = newArtist;
                saveLibrary();
                hideEditModal();
                renderLibrary();

                if (isPlayingFromLibrary && currentPlaylistIndex === index) {
                    // Force update player info with new names, but keep playing the current track
                    // Use updatePlayerInfoUI directly to refresh UI without restarting video
                    updatePlayerInfoUI(userLibrary[index]);
                }
            } else {
                console.error("Title and Artist cannot be empty.");
            }
        }

        function hideEditModal() {
            ui.editModal.style.display = 'none';
            ui.editModal.removeAttribute('data-edit-index');
        }

        async function renderLibrary() {
            ui.musicView.innerHTML = '';
            ui.channelBanner.classList.add('hidden');
            
            if (userLibrary.length === 0) {
                ui.musicView.innerHTML = '<p class="col-span-full text-xl text-gray-500 font-light">Your library is empty. Add songs from search results!</p>';
                return;
            }

            for (let index = 0; index < userLibrary.length; index++) {
                const song = userLibrary[index];
                const card = document.createElement('div');
                card.className = 'music-card library-card'; 
                
                const displayTitle = await filterExplicitText(decodeHtmlEntities(song.title));
                const displayArtist = await filterExplicitText(decodeHtmlEntities(song.artist));

                // --- LIBRARY CARD STRUCTURE ---
                card.innerHTML = `
                    <div class="card-background" style="background-image: url('${song.thumbnail}');"></div>

                    <div class="card-overlay">
                        <div class="card-details">
                            <h3 class="text-xl font-medium mb-1 line-clamp-2">${displayTitle}</h3>
                            <p class="text-sm text-gray-300 font-light line-clamp-1">${displayArtist}</p>
                        </div>
                        
                        <div class="card-actions flex-col space-y-2 !opacity-100">
                            <button class="play-library-btn w-3/4 p-2 rounded-lg text-sm font-semibold glass-button glass-button-red">
                                <i class="fa-solid fa-play mr-2"></i> Play
                            </button>
                            <div class="flex space-x-2 w-3/4">
                                <button class="edit-library-btn flex-grow p-2 rounded-lg text-sm font-semibold glass-button" title="Edit Names">
                                    <i class="fa-solid fa-pencil mr-1"></i> Edit
                                </button>
                                <button class="remove-library-btn p-2 rounded-lg text-sm font-semibold glass-button hover:bg-red-900/50" title="Remove from Library">
                                    <i class="fa-solid fa-trash-can"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                // --- END LIBRARY CARD STRUCTURE ---
                
                // Play
                const playHandler = (e) => {
                    e.stopPropagation();
                    startPlaylist(userLibrary, index, true);
                };
                card.addEventListener('click', playHandler);
                card.querySelector('.play-library-btn').addEventListener('click', playHandler);
                
                // Edit
                card.querySelector('.edit-library-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    showEditModal(index);
                });

                // Remove 
                card.querySelector('.remove-library-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeFromLibrary(song.videoId);
                });

                ui.musicView.appendChild(card);
            };
        }
        
        function promptAddUrl() {
            const url = window.prompt("Enter a YouTube Video URL:");
            if (url) {
                const videoIdMatch = url.match(/(?:\?v=|\/embed\/|\/v\/|youtu\.be\/|\/shorts\/)([a-zA-Z0-9_-]{11})[^#&]*/);
                if (videoIdMatch && videoIdMatch[1]) {
                    const videoId = videoIdMatch[1];
                    const songData = {
                        videoId: videoId,
                        title: `Manual Track: ${videoId}`, 
                        artist: 'Manual Entry',
                        thumbnail: `https://img.youtube.com/vi/${videoId}/mqdefault.jpg` 
                    };
                    addToLibrary(songData);
                } else {
                    console.error("Invalid YouTube URL. Please ensure it contains a valid video ID.");
                }
            }
        }


        // --- EVENT LISTENERS & NAVIGATION ---

        function attachEventListeners() {
            ui.searchButton.addEventListener('click', () => {
                const query = ui.searchInput.value.trim();
                if (query) {
                    performSearch(query);
                    switchView('home');
                }
            });
            
            ui.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    ui.searchButton.click();
                }
            });

            ui.playPauseBtn.addEventListener('click', togglePlayPause);
            ui.skipBackBtn.addEventListener('click', skipBack);
            ui.skipNextBtn.addEventListener('click', skipNext);
            
            // Go Back Button Listener
            ui.goBackButton.addEventListener('click', goBackToLastSearch);

            // Library Button Logic (Remove if active, Add if inactive)
            ui.addToLibraryBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const btn = e.currentTarget;
                const videoId = btn.dataset.videoId;
                
                if (!videoId) return;

                if (btn.dataset.inLibrary === 'true') {
                    removeFromLibrary(videoId);
                    return;
                }
                
                // Action: ADD to library
                const songData = {
                    videoId: videoId,
                    title: btn.dataset.title,
                    artist: btn.dataset.artist,
                    thumbnail: btn.dataset.thumbnail
                };
                addToLibrary(songData);
            });

            ui.navTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    switchView(e.currentTarget.dataset.view);
                });
            });
            
            // Modal Listeners
            ui.modalSaveBtn.addEventListener('click', saveNameEdit);
            ui.modalCancelBtn.addEventListener('click', hideEditModal);
            ui.editModal.addEventListener('click', (e) => {
                if (e.target === ui.editModal) {
                    hideEditModal();
                }
            });

            // Keyboard Controls Listener
            document.addEventListener('keydown', handleKeyPress);
            
            // Optional: Re-run marquee check on window resize
            window.addEventListener('resize', () => {
                 if(ui.bottomPlayer.classList.contains('player-visible')) {
                    updateMarquee(ui.currentTitle, ui.currentTitleContainer);
                    updateMarquee(ui.currentArtist, ui.currentArtistContainer);
                 }
            });
        }
        
        /**
         * Handles global keyboard shortcuts for playback control.
         */
        function handleKeyPress(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
            }

            if (!ytPlayer || currentPlaylistIndex === -1 || !isPlayerReady) return;

            const state = ytPlayer.getPlayerState();
            const currentTime = ytPlayer.getCurrentTime();

            if (e.shiftKey) {
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    skipNext();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    skipBack();
                }
                return;
            }

            switch (e.key) {
                case ' ': 
                    if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.PAUSED) {
                        togglePlayPause();
                    }
                    break;
                case 'm': 
                case 'M':
                    if (ytPlayer.isMuted()) {
                        ytPlayer.unMute();
                    } else {
                        ytPlayer.mute();
                    }
                    break;
                case 'ArrowLeft': 
                    if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.PAUSED) {
                        ytPlayer.seekTo(currentTime - 10, true);
                    }
                    break;
                case 'ArrowRight': 
                    if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.PAUSED) {
                        ytPlayer.seekTo(currentTime + 10, true);
                    }
                    break;
            }
        }

        function switchView(view) {
            ui.navTabs.forEach(tab => {
                const isActive = tab.dataset.view === view;
                tab.classList.toggle('border-red-600', isActive);
                tab.classList.toggle('text-red-500', isActive);
                tab.classList.toggle('border-transparent', !isActive);
                tab.classList.toggle('text-gray-400', !isActive);
            });

            if (view === 'library') {
                renderLibrary();
            } else {
                if (currentChannelTitle) {
                     ui.channelBanner.classList.remove('hidden');
                     ui.channelBanner.style.display = 'flex';
                } else {
                     ui.channelBanner.classList.add('hidden');
                }
                
                if (currentPlaylist.length === 0) {
                     ui.musicView.innerHTML = '<p class="col-span-full text-gray-500 font-light">Enter a query above and click "Search" to find music videos/artists.</p>';
                } else {
                    renderSearchResults(currentPlaylist.map(song => ({
                        id: { kind: 'youtube#video', videoId: song.videoId },
                        snippet: { title: song.title, channelTitle: song.artist, thumbnails: { medium: { url: song.thumbnail } } }
                    })));
                }
            }
        }

        // Expose necessary functions/data globally
        window.startPlaylist = startPlaylist;
        window.userLibrary = userLibrary;
        window.promptAddUrl = promptAddUrl; 
        window.performSearch = performSearch; // EXPOSED: To fix a possible ReferenceError
        window.goBackToLastSearch = goBackToLastSearch; // EXPOSED: To fix a possible ReferenceError

        // Helper function for custom confirmation modal (replaces window.confirm)
        window.confirm = (message) => {
            return window.prompt(message + " (Type 'yes' to confirm)")?.toLowerCase() === 'yes';
        }

    </script>
</body>
</html>
