<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messenger | 4SP Theme (Fullscreen)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://kit-pro.fontawesome.com/releases/v7.0.1/css/pro.min.css" media="all">

    <script>
        // Remove default Tailwind config
    </script>

    <style>
        /* --- FONT & BASE STYLING (MATCHING notes.html) --- */
        :root {
            --menu-bg: #000000;
            --menu-border: #333;
            --menu-text: #d1d5db;
            --tab-hover-text: #ffffff;
            --tab-active-bg: rgba(79, 70, 229, 0.1);
            --tab-active-border: #4f46e5;
            --tab-active-text: #4f46e5;
            --tab-active-hover-bg: rgba(79, 70, 229, 0.15);
            --tab-active-hover-border: #6366f1;
            --tab-active-hover-text: #6366f1;
            --tab-text: #9ca3af;
            --menu-item-hover-bg: #2a2a2a;
            --menu-item-hover-text: #ffffff;
            --avatar-border: #4b5563;
        }

        body { 
            font-family: 'Geist', sans-serif; 
            background-color: #070707; 
            color: #c0c0c0; 
            transition: all 0.3s ease;
            font-size: 16px;
            overflow: hidden; /* Prevent body scroll on fullscreen */
            font-weight: 300; 
        }

        h1, h2, h3, .font-bold, .font-semibold, strong, .tracking-widest {
            font-weight: 400 !important; 
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        .view-transition { transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; }
        .view-hidden { opacity: 0; transform: scale(0.98); pointer-events: none; }
        
        /* --- THEME-AWARE BUTTONS (LESS ROUND) --- */
        
        .btn-themed-secondary {
            background: var(--menu-bg, #0000000);
            border: 1px solid var(--menu-border, #333);
            border-radius: 0.5rem; /* 8px */
            color: var(--menu-text, #d1d5db);
            padding: 0.5rem 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            line-height: 1;
        }
        .btn-themed-secondary:hover {
            background-color: var(--menu-bg, #000000);
            border-color: var(--menu-border, #fff);
            color: var(--tab-hover-text, #ffffff);
        }

        .btn-themed-primary {
            background-color: var(--tab-active-bg, rgba(79, 70, 229, 0.1));
            border: 1px solid var(--tab-active-border, #4f46e5);
            color: var(--tab-active-text, #4f46e5);
            border-radius: 0.5rem; /* 8px */
            padding: 0.5rem 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-themed-primary:hover {
            background-color: var(--tab-active-hover-bg, rgba(79, 70, 229, 0.15));
            border-color: var(--tab-active-hover-border, #6366f1);
            color: var(--tab-active-hover-text, #6366f1);
        }
        .btn-themed-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--tab-active-bg, rgba(79, 70, 229, 0.1));
            border-color: var(--tab-active-border, #4f46e5);
            color: var(--tab-active-text, #4f46e5);
        }

        .btn-icon-theme {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.25rem; /* 36px */
            height: 2.25rem; /* 36px */
            border-radius: 0.5rem; /* 8px */
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--tab-text, #9ca3af);
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-icon-theme:hover {
            background-color: var(--tab-active-bg, rgba(79, 70, 229, 0.1));
            color: var(--tab-active-text, #4f46e5);
            border-color: var(--tab-active-border, #4f46e5);
        }
        .btn-icon-theme.btn-danger:hover {
            background-color: rgba(220, 38, 38, 0.1);
            color: #dc2626;
            border-color: #dc2626;
        }

        /* --- THEMED INPUT (LESS ROUND) --- */
        .themed-input {
            background-color: #0d0d0d;
            border: 1px solid #1a1a1a;
            color: #c0c0c0;
            border-radius: 0.5rem; /* 8px */
            padding: 0.75rem 1rem;
            transition: all 0.2s;
            width: 100%;
        }
        .themed-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .themed-input::placeholder { color: #707070; font-weight: 300; }

        /* --- NEW: Auto-Expanding Textarea Styles --- */
        .auto-expand-textarea {
            resize: none; /* Disable manual resize handle */
            overflow-y: hidden; /* Hide scrollbar initially */
            min-height: 3.5rem; 
            max-height: 150px; /* Max height before scroll is hit */
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            line-height: 1.5; /* Ensure text line height is correct */
            box-sizing: border-box; /* Include padding and border in the element's total height */
        }
        .auto-expand-textarea.scrollable {
            overflow-y: auto; /* Show scrollbar when max-height is reached */
        }
        
        /* --- MESSENGER LAYOUT STYLES --- */
        #app-container {
            background-color: #070707;
        }
        #contacts-view {
            background-color: #070707; 
            border-color: #1a1a1a;
        }
        .themed-header, .themed-footer { border-color: #1a1a1a; }
        .themed-footer { background-color: #070707; }
        #chat-view { background-color: #0d0d0d; }
        #my-id-box { background-color: #0d0d0d; border: 1px solid #1a1a1a; border-radius: 0.5rem; } /* 8px */

        /* --- FRIEND/REQUEST LIST --- */
        .friend-list-item {
            padding: 0.75rem 1rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            border-radius: 0.5rem; /* 8px */
            margin: 0.25rem 1rem;
            width: calc(100% - 2rem);
            display: flex;
            align-items: center;
            gap: 1rem; 
            cursor: pointer;
        }
        .friend-list-item:hover {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .friend-list-item.active {
            background-color: var(--tab-active-bg, rgba(79, 70, 229, 0.1));
            color: var(--tab-active-text, #4f46e5);
            font-weight: 400;
        }
        .friend-list-item.active .font-thin {
            color: var(--tab-active-text, #4f46e5);
        }
        
        .contact-initials {
            background-color: #1a1a1a;
            color: #c0c0c0;
            font-weight: 400;
            width: 40px; 
            height: 40px;
            border-radius: 99px; /* Still round, as is standard */
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .friend-list-item.active .contact-initials {
            background-color: var(--tab-active-border);
            color: white;
        }
        
        /* --- Friend Request Item Styling --- */
        .request-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background-color: #0d0d0d;
            border: 1px solid #1a1a1a;
            border-radius: 0.5rem; /* 8px */
        }
        .request-item .btn-icon-theme {
            width: 2rem;
            height: 2rem;
        }
        .request-item .btn-icon-theme.btn-accept:hover {
            background-color: rgba(34, 197, 94, 0.1);
            border-color: #22c55e;
            color: #22c55e;
        }

        /* --- REDESIGNED MESSAGE BUBBLES (Button Styled) --- */
        .message-bubble {
            padding: 0.75rem 1.2rem; /* Slightly larger padding for button look */
            border-radius: 0.75rem;
            /* max-width: 50%; <--- REMOVED */
            word-break: break-word;
            border-width: 1px;
            transition: all 0.2s; 
        }
        .sent-bubble {
            /* Styled like btn-themed-primary */
            background-color: var(--tab-active-bg, rgba(79, 70, 229, 0.1));
            border-color: var(--tab-active-border, #4f46e5);
            color: var(--tab-active-text, #4f46e5);
            border-bottom-right-radius: 0.25rem;
        }
        .received-bubble {
            /* Styled like btn-themed-secondary */
            background-color: var(--menu-bg, #000000);
            border-color: var(--menu-border, #333);
            color: var(--menu-text, #d1d5db);
            border-bottom-left-radius: 0.25rem;
        }
        .message-text {
            font-weight: 300;
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre-wrap; /* Allows wrapping but respects newlines */
            min-width: 1rem; 
        }
        /* Ensure text and links inside the new bubbles inherit color */
        .sent-bubble .message-text, .sent-bubble .message-text a {
            color: var(--tab-active-text, #4f46e5);
        }
        .received-bubble .message-text, .received-bubble .message-text a {
            color: var(--menu-text, #d1d5db);
        }
        
        /* --- Redesigned Timestamp and Seen Status --- */
        .message-timestamp {
            font-weight: 300;
            font-size: 0.75rem;
            margin-top: 4px;
            color: #707070; 
        }
        .sent-bubble + .message-timestamp { 
            color: var(--tab-active-text, #4f46e5); /* Themed color for sent message timestamp/seen */
        }
        .received-bubble + .message-timestamp { 
            color: var(--menu-text, #9ca3af); /* Lighter gray for received */
        }
        .message-timestamp .seen-status {
            color: var(--tab-active-border); 
            font-weight: 400;
        }

        /* --- NEW: Expandable Message Content (Updated for better look/UX) --- */
        .message-content {
            max-height: 2000px; /* Default max-height for animation */
            transition: max-height 0.3s ease-in-out;
            overflow: hidden;
            position: relative;
        }
        .message-content.truncated {
            max-height: 120px;
        }
        /* Fade-out for truncated text: SCOPED TO BUBBLE TYPE */
        .message-content.truncated::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            pointer-events: none; 
            z-index: 10;
        }
        .received-bubble .message-content.truncated::after {
            /* Fade to received bubble background */
            background: linear-gradient(to bottom, transparent, var(--menu-bg) 90%);
        }
        .sent-bubble .message-content.truncated::after {
            /* Fade to sent bubble background */
            background: linear-gradient(to bottom, transparent, var(--tab-active-bg) 90%);
        }

        /* "Show More" arrow: SCOPED TO BUBBLE TYPE AND IMPROVED UI */
        .fade-arrow {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            padding: 2px 8px; /* Slightly wider padding */
            border-radius: 99px;
            border-width: 1px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
        }
        .received-bubble .fade-arrow {
            background-color: var(--menu-bg, #000000);
            border-color: var(--menu-border, #333);
            color: var(--menu-text, #d1d5db);
        }
        .received-bubble .fade-arrow:hover {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .sent-bubble .fade-arrow {
            background-color: var(--tab-active-bg, rgba(79, 70, 229, 0.1));
            border-color: var(--tab-active-border, #4f46e5);
            color: var(--tab-active-text, #4f46e5);
        }
        .sent-bubble .fade-arrow:hover {
            background-color: var(--tab-active-hover-bg, rgba(79, 70, 229, 0.15));
            border-color: var(--tab-active-hover-border, #6366f1);
            color: var(--tab-active-hover-text, #6366f1);
        }
        /* Class to be toggled by JS */
        .fade-arrow.expanded i {
            transform: rotate(180deg);
        }
        
        /* --- Input Bar (LESS ROUND) --- */
        .btn-themed-primary.btn-send {
            border-radius: 0.5rem; /* 8px */
            padding-left: 0;
            padding-right: 0;
            line-height: 1;
        }
        
        /* --- Image Attachment Styles (Unchanged) --- */
        #image-preview-container {
            border-color: #1a1a1a;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 0.5rem;
        }
        .image-preview-item {
            position: relative;
            width: 4rem; /* 64px */
            height: 4rem; /* 64px */
            border-radius: 0.375rem; /* 6px */
            overflow: hidden;
            flex-shrink: 0;
            border: 1px solid #1a1a1a;
        }
        .remove-image-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 16px;
            height: 16px;
            background-color: #dc2626;
            color: white;
            border: none;
            border-radius: 99px;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            z-index: 10;
        }
        
        /* Image grid is now horizontally scrolling */
        .message-bubble .image-attachment-grid {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            overflow-x: auto; /* Horizontal scroll */
            padding-bottom: 8px; /* Give room for scrollbar */
            max-width: 100%; 
        }
        .message-bubble .image-attachment {
            height: 120px; /* Set height */
            width: auto; /* Auto width to maintain aspect ratio */
            max-width: 256px; /* Cap max width for extremely wide images */
            border-radius: 0.5rem; /* 8px */
            object-fit: cover; /* Use cover to fill the 120px height */
            cursor: pointer;
            transition: opacity 0.2s;
            flex-shrink: 0; /* Important for horizontal scroll */
        }
        .message-bubble .image-attachment:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body class="bg-[#070707] text-gray-200">

    <div id="app-container" class="hidden w-screen h-screen flex overflow-hidden backdrop-blur-xl">
        
        <div id="contacts-view" class="w-full sm:w-80 h-full flex flex-col flex-shrink-0 view-transition sm:relative absolute top-0 left-0 z-10 border-r">
            
            <header class="p-4 border-b themed-header flex-shrink-0">
                <div class="flex justify-between items-center">
                    <h1 class="font-display text-2xl font-bold text-white">Messenger <span class="text-indigo-400 text-lg font-normal">2.0</span></h1>
                    <div class="flex items-center gap-3">
                        <div id="status-icons" class="text-xs font-mono hidden md:flex items-center gap-2 text-gray-500 font-thin">
                            <span id="battery-status">--%</span>
                            <span>|</span>
                            <span id="local-time">--:--</span>
                        </div>
                    </div>
                </div>
                <div id="my-id-box" class="mt-4 p-3 flex items-center justify-between">
                    <div class="flex items-center gap-2 overflow-hidden">
                        <span class="text-sm font-medium text-gray-400 flex-shrink-0">My ID:</span>
                        <span id="my-id" class="font-mono text-sm truncate text-gray-300 font-semibold">loading...</span>
                    </div>
                    <button id="copy-id-btn" class="btn-themed-secondary text-xs px-3 py-1">Copy</button>
                </div>
            </header>

            <div class="p-4 border-b themed-header flex-shrink-0">
                <div class="flex gap-2">
                    <button id="tab-btn-friends" class="btn-themed-primary flex-1">Friends</button>
                    <button id="tab-btn-requests" class="btn-themed-secondary flex-1">
                        Requests
                        <span id="requests-badge" class="hidden ml-1 bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full">0</span>
                    </button>
                </div>
            </div>

            <div id="tab-content-friends" class="flex-grow overflow-y-auto">
                <ul id="friends-list" class="divide-y divide-[#1a1a1a]"></ul>
            </div>
            
            <div id="tab-content-requests" class="flex-grow overflow-y-auto p-4 space-y-4 hidden">
                <div>
                    <h3 class="text-lg font-semibold mb-2">Add Friend</h3>
                    <div class="flex gap-2">
                        <input type="text" id="add-contact-id" placeholder="Enter friend's 8-character ID" class="themed-input p-3">
                        <button id="add-contact-btn" class="btn-themed-primary px-4 py-2">Send</button>
                    </div>
                    <p id="add-friend-message" class="text-sm mt-2 font-thin"></p>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-2">Incoming</h3>
                    <ul id="incoming-requests-list" class="space-y-2">
                    </ul>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-2">Outgoing</h3>
                    <ul id="outgoing-requests-list" class="space-y-2">
                    </ul>
                </div>
            </div>
        </div>

        <div id="chat-view" class="w-full h-full flex flex-col view-transition sm:w-[calc(100%-20rem)] sm:relative absolute top-0 left-0 view-hidden">
            <header class="p-4 border-b themed-header flex items-center justify-between flex-shrink-0">
                <button id="back-to-contacts-btn" class="btn-icon-theme sm:hidden">
                    <i class="fa-solid fa-chevron-left w-5 h-5"></i>
                </button>
                <h2 id="chat-header" class="text-lg font-semibold">Select a Chat</h2>
                <button id="lcc-btn" class="btn-icon-theme btn-danger text-red-500" title="Clear Local Chat History">
                    <i class="fa-solid fa-trash-can w-5 h-5"></i>
                </button>
            </header>
            
            <div class="chat-messages flex-grow overflow-y-auto p-4 space-y-4" id="messages-container">
                <div id="chat-placeholder" class="h-full flex items-center justify-center text-center text-gray-400 font-thin">
                    <p>Start a conversation by selecting a friend from the sidebar.</p>
                </div>
            </div>
            
            <footer class="p-4 border-t themed-footer flex-shrink-0 flex flex-col">
                <div id="image-preview-container" class="hidden mb-2 flex gap-2 overflow-x-auto border border-dashed">
                    </div>
                <form id="message-form" class="flex gap-3 items-end"> 
                    <button type="button" id="attach-image-btn" class="btn-icon-theme w-10 h-10 flex-shrink-0 mb-1">
                        <i class="fa-solid fa-paperclip w-5 h-5"></i>
                    </button>
                    <textarea 
                        id="message-input" 
                        placeholder="Type a message (Enter to send, Shift+Enter for new line)..." 
                        maxlength="10000" 
                        class="themed-input auto-expand-textarea py-2 px-4"
                        rows="1"></textarea>
                    <button type="submit" id="send-btn" class="btn-themed-primary btn-send w-10 h-10 flex-shrink-0 mb-1">
                        <i class="fa-solid fa-arrow-up w-5 h-5"></i>
                    </button>
                </form>
            </footer>
        </div>
    </div>
    
    <input type="file" id="image-input" multiple accept="image/*" class="hidden">

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, serverTimestamp, arrayUnion, arrayRemove, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref as storageRef, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";


        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyASqfiYUPf7xY4wgZ0hLl8_Z0ZkBiwFUO8",
            authDomain: "theamericanmessenger-0.firebaseapp.com",
            databaseURL: "https://theamericanmessenger-0-default-rtdb.firebaseio.com",
            projectId: "theamericanmessenger-0",
            storageBucket: "theamericanmessenger-0.firebasestorage.app",
            messagingSenderId: "963196851685",
            appId: "1:963196851685:web:9f709be8b2888ed4e28b0c",
            measurementId: "G-SBGEJDRSBZ"
        };
        
        // --- INITIALIZE APP ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        // --- GLOBAL STATE & CONSTANTS ---
        let currentUser = null;
        let currentChatPartner = null;
        let myPublicId = null;
        let myPublicName = null;
        let blockedUsers = [];
        let unsubscribeUserDoc = () => {};
        let unsubscribeFriends = () => {};
        let unsubscribeIncomingRequests = () => {};
        let unsubscribeOutgoingRequests = () => {};
        let unsubscribeMessages = () => {};
        let statusInterval = null;
        let imageAttachmentsBase64 = [];
        let lastMessageCount = 0; // For scroll control

        const MESSAGE_TRUNCATE_LENGTH = 400; // Character limit for truncation
        const MESSAGE_LIMIT = 25; // Number of messages to load from chat history
        const SEEN_DELAY_MS = 1000; // Delay before marking a message as seen

        const dom = {
            appContainer: document.getElementById('app-container'),
            myIdEl: document.getElementById('my-id'),
            copyIdBtn: document.getElementById('copy-id-btn'),
            addContactIdInput: document.getElementById('add-contact-id'),
            addContactBtn: document.getElementById('add-contact-btn'),
            addFriendMessage: document.getElementById('add-friend-message'),
            friendsListEl: document.getElementById('friends-list'),
            incomingRequestsListEl: document.getElementById('incoming-requests-list'),
            outgoingRequestsListEl: document.getElementById('outgoing-requests-list'),
            tabBtnFriends: document.getElementById('tab-btn-friends'),
            tabBtnRequests: document.getElementById('tab-btn-requests'),
            tabContentFriends: document.getElementById('tab-content-friends'),
            tabContentRequests: document.getElementById('tab-content-requests'),
            requestsBadge: document.getElementById('requests-badge'),
            contactsView: document.getElementById('contacts-view'),
            chatView: document.getElementById('chat-view'),
            backToContactsBtn: document.getElementById('back-to-contacts-btn'),
            chatHeaderEl: document.getElementById('chat-header'),
            messagesContainerEl: document.getElementById('messages-container'),
            messageForm: document.getElementById('message-form'),
            messageInput: document.getElementById('message-input'), // Now a <textarea>
            sendBtn: document.getElementById('send-btn'),
            batteryStatusEl: document.getElementById('battery-status'),
            localTimeEl: document.getElementById('local-time'),
            chatPlaceholder: document.getElementById('chat-placeholder'),
            // NEW: Image elements
            attachImageBtn: document.getElementById('attach-image-btn'),
            imageInput: document.getElementById('image-input'),
            imagePreviewContainer: document.getElementById('image-preview-container'),
            // NEW: LCC Button
            lccBtn: document.getElementById('lcc-btn'),
        };

        const icons = {
            send: `<i class="fa-solid fa-arrow-up w-5 h-5"></i>`,
            check: `<i class="fa-solid fa-check w-5 h-5"></i>`,
            arrowDown: `<i class="fa-solid fa-chevron-down w-3 h-3"></i>`,
            accept: `<i class="fa-solid fa-check w-4 h-4"></i>`,
            deny: `<i class="fa-solid fa-xmark w-4 h-4"></i>`,
            cancel: `<i class="fa-solid fa-trash-can w-4 h-4"></i>`,
        };

        // --- UTILITY FUNCTIONS ---
        
        // NEW: Generates a random 8-character ID
        async function generateUniqueId() {
            let id;
            let docRef;
            let docSnap;
            do {
                id = Math.random().toString(36).substring(2, 10).toUpperCase();
                docRef = doc(db, 'public_ids', id);
                docSnap = await getDoc(docRef);
            } while (docSnap.exists());
            
            await setDoc(docRef, { uid: currentUser.uid });
            return id;
        }

        function getChatId(uid1, uid2) {
            return [uid1, uid2].sort().join('_');
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return 'Time Unknown';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // NEW: Auto-expanding textarea logic
        function autoExpandTextarea(element) {
            // Reset height to auto to correctly calculate scrollHeight
            element.style.height = 'auto';
            
            // Set element height to its scroll height
            let newHeight = element.scrollHeight;
            let maxHeight = parseInt(window.getComputedStyle(element).maxHeight.replace('px', ''));
            
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                element.classList.add('scrollable');
            } else {
                element.classList.remove('scrollable');
            }
            
            element.style.height = newHeight + 'px';
        }

        // --- MAIN APP LOGIC ---
        function main() {
            setupEventListeners();
            signInAnonymously(auth).catch(err => console.error("Sign-in failed:", err));
            onAuthStateChanged(auth, handleAuthStateChange);
        }

        async function handleAuthStateChange(user) {
            if (user) {
                currentUser = user;
                await setupUserDocument();
                listenForUserDocChanges();
                listenForFriends();
                listenForFriendRequests();
                startStatusUpdates();
                dom.appContainer.classList.remove('hidden');
                dom.messageInput.style.height = 'auto'; // Reset textarea height on load
            } else {
                stopStatusUpdates();
                dom.appContainer.classList.add('hidden');
            }
        }

        async function setupUserDocument() {
            const userDocRef = doc(db, 'users', currentUser.uid);
            const userDoc = await getDoc(userDocRef);
            if (!userDoc.exists()) {
                const newId = await generateUniqueId();
                const defaultName = 'User ' + newId.substring(0, 4);
                await setDoc(userDocRef, { publicId: newId, uid: currentUser.uid, blockedUsers: [], name: defaultName, });
                myPublicId = newId;
                myPublicName = defaultName;
                dom.myIdEl.textContent = newId;
            } else {
                const data = userDoc.data();
                myPublicId = data.publicId;
                myPublicName = data.name || 'Unknown';
                dom.myIdEl.textContent = myPublicId;
                blockedUsers = data.blockedUsers || [];
            }
        }

        function listenForUserDocChanges() {
            unsubscribeUserDoc();
            const userDocRef = doc(db, 'users', currentUser.uid);
            unsubscribeUserDoc = onSnapshot(userDocRef, (doc) => {
                if (doc.exists()) {
                    blockedUsers = doc.data().blockedUsers || [];
                    myPublicName = doc.data().name || 'Unknown';
                    // Re-render friends list to update block/unblock buttons
                    listenForFriends(); 
                    if (currentChatPartner) {
                        // Check if current partner is now blocked or blocked us
                        listenForMessages(); 
                    }
                }
            });
        }

        // --- FRIEND & REQUEST MANAGEMENT ---

        function listenForFriends() {
            unsubscribeFriends();
            const friendsCollectionRef = collection(db, `users/${currentUser.uid}/contacts`);
            // Query friends (contacts are essentially friends)
            const q = query(friendsCollectionRef, where('isFriend', '==', true));

            unsubscribeFriends = onSnapshot(q, (snapshot) => {
                dom.friendsListEl.innerHTML = '';
                snapshot.forEach(doc => {
                    const friend = doc.data();
                    renderFriendListItem(friend);
                });
            });
        }

        function renderFriendListItem(friend) {
            const item = document.createElement('li');
            const isActive = currentChatPartner?.uid === friend.uid;
            const hasUnread = friend.unread === true;
            
            // Determine initials and color
            const initials = friend.name ? friend.name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase() : '??';

            item.className = `friend-list-item ${isActive ? 'active' : ''}`;
            item.dataset.uid = friend.uid;
            item.dataset.name = friend.name;
            item.innerHTML = `
                <div class="contact-initials">${initials}</div>
                <div class="flex-grow overflow-hidden">
                    <div class="flex items-center justify-between">
                        <span class="font-medium truncate ${hasUnread ? 'text-white' : ''}">${friend.name || 'Unknown User'}</span>
                        ${hasUnread ? `<span class="w-2 h-2 bg-red-500 rounded-full flex-shrink-0"></span>` : ''}
                    </div>
                    <p class="text-xs font-thin truncate ${hasUnread ? 'text-red-300' : 'text-gray-400'}">
                        ${friend.lastMessage ? friend.lastMessage : 'No messages yet'}
                    </p>
                </div>
            `;
            dom.friendsListEl.appendChild(item);
        }

        async function handleContactsListClick(e) {
            const item = e.target.closest('.friend-list-item');
            if (item) {
                const uid = item.dataset.uid;
                const name = item.dataset.name;
                
                // Remove 'active' class from all, add to clicked item
                document.querySelectorAll('.friend-list-item').forEach(el => el.classList.remove('active'));
                item.classList.add('active');
                
                await openChat(uid, name);
            }
        }

        function listenForFriendRequests() {
            unsubscribeIncomingRequests();
            unsubscribeOutgoingRequests();

            // Incoming Requests
            const incomingRef = collection(db, `users/${currentUser.uid}/requests`);
            const qIncoming = query(incomingRef, where('type', '==', 'incoming'));
            unsubscribeIncomingRequests = onSnapshot(qIncoming, (snapshot) => {
                dom.incomingRequestsListEl.innerHTML = '';
                let count = 0;
                snapshot.forEach(doc => {
                    renderRequestItem(doc.data(), doc.id, 'incoming');
                    count++;
                });
                updateRequestsBadge(count);
            });

            // Outgoing Requests
            const outgoingRef = collection(db, `users/${currentUser.uid}/requests`);
            const qOutgoing = query(outgoingRef, where('type', '==', 'outgoing'));
            unsubscribeOutgoingRequests = onSnapshot(qOutgoing, (snapshot) => {
                dom.outgoingRequestsListEl.innerHTML = '';
                snapshot.forEach(doc => {
                    renderRequestItem(doc.data(), doc.id, 'outgoing');
                });
            });
        }

        function updateRequestsBadge(count) {
            if (count > 0) {
                dom.requestsBadge.textContent = count;
                dom.requestsBadge.classList.remove('hidden');
            } else {
                dom.requestsBadge.classList.add('hidden');
            }
        }

        function renderRequestItem(request, docId, type) {
            const listEl = type === 'incoming' ? dom.incomingRequestsListEl : dom.outgoingRequestsListEl;
            const item = document.createElement('li');
            item.className = 'request-item';

            // Determine initials
            const initials = request.senderName ? request.senderName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase() : '??';

            item.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="contact-initials text-sm">${initials}</div>
                    <span class="text-sm font-thin">${request.senderName || request.senderPublicId}</span>
                </div>
                <div>
                    ${type === 'incoming' ? `
                        <button class="btn-icon-theme btn-accept mr-1" data-action="accept-request" data-id="${docId}">
                            ${icons.accept}
                        </button>
                        <button class="btn-icon-theme btn-danger" data-action="deny-request" data-id="${docId}">
                            ${icons.deny}
                        </button>
                    ` : `
                        <button class="btn-icon-theme btn-danger" data-action="cancel-request" data-id="${docId}">
                            ${icons.cancel}
                        </button>
                    `}
                </div>
            `;
            listEl.appendChild(item);
        }

        async function handleAddContact() {
            const targetId = dom.addContactIdInput.value.trim().toUpperCase();
            if (targetId.length !== 8) {
                dom.addFriendMessage.textContent = 'Please enter a valid 8-character ID.';
                dom.addFriendMessage.className = 'text-sm mt-2 text-red-400 font-thin';
                return;
            }
            if (targetId === myPublicId) {
                dom.addFriendMessage.textContent = 'You cannot add yourself!';
                dom.addFriendMessage.className = 'text-sm mt-2 text-red-400 font-thin';
                return;
            }

            try {
                // 1. Find the UID for the public ID
                const publicIdDoc = await getDoc(doc(db, 'public_ids', targetId));
                if (!publicIdDoc.exists()) {
                    dom.addFriendMessage.textContent = 'User ID not found.';
                    dom.addFriendMessage.className = 'text-sm mt-2 text-red-400 font-thin';
                    return;
                }
                const targetUid = publicIdDoc.data().uid;

                // 2. Check for existing friendship or pending request (outgoing)
                const contactDoc = await getDoc(doc(db, `users/${currentUser.uid}/contacts`, targetUid));
                if (contactDoc.exists() && contactDoc.data().isFriend) {
                    dom.addFriendMessage.textContent = 'You are already friends with this user.';
                    dom.addFriendMessage.className = 'text-sm mt-2 text-yellow-400 font-thin';
                    return;
                }
                const existingRequestDoc = await getDoc(doc(db, `users/${currentUser.uid}/requests`, targetUid));
                if (existingRequestDoc.exists() && existingRequestDoc.data().type === 'outgoing') {
                    dom.addFriendMessage.textContent = 'Request already sent.';
                    dom.addFriendMessage.className = 'text-sm mt-2 text-yellow-400 font-thin';
                    return;
                }

                // 3. Create the batch write
                const batch = writeBatch(db);

                // A. Outgoing request in my own queue
                batch.set(doc(db, `users/${currentUser.uid}/requests`, targetUid), {
                    type: 'outgoing',
                    senderUid: currentUser.uid,
                    senderPublicId: myPublicId,
                    senderName: myPublicName,
                    timestamp: serverTimestamp()
                });

                // B. Incoming request in the target user's queue
                batch.set(doc(db, `users/${targetUid}/requests`, currentUser.uid), {
                    type: 'incoming',
                    senderUid: currentUser.uid,
                    senderPublicId: myPublicId,
                    senderName: myPublicName,
                    timestamp: serverTimestamp()
                });

                await batch.commit();

                dom.addFriendMessage.textContent = 'Friend request sent!';
                dom.addFriendMessage.className = 'text-sm mt-2 text-green-400 font-thin';
                dom.addContactIdInput.value = '';
            } catch (error) {
                console.error("Error sending friend request:", error);
                dom.addFriendMessage.textContent = 'Failed to send request. Try again.';
                dom.addFriendMessage.className = 'text-sm mt-2 text-red-400 font-thin';
            }
        }

        async function handleRequestAction(e) {
            const btn = e.target.closest('button');
            const action = btn?.dataset.action;
            const targetUid = btn?.dataset.id; 
            
            if (!action || !targetUid) return;

            try {
                if (action === 'accept-request') {
                    await acceptRequest(targetUid);
                } else if (action === 'deny-request' || action === 'cancel-request') {
                    await removeRequest(targetUid, action === 'cancel-request');
                }
            } catch (error) {
                console.error(`Error handling request action ${action}:`, error);
                alert(`Failed to complete action: ${error.message}`);
            }
        }

        async function acceptRequest(targetUid) {
            // 1. Get sender info from the request doc before deleting it
            const incomingRef = doc(db, `users/${currentUser.uid}/requests`, targetUid);
            const incomingSnap = await getDoc(incomingRef);
            if (!incomingSnap.exists()) throw new Error("Incoming request not found.");
            const senderData = incomingSnap.data();

            const batch = writeBatch(db);
            
            // 2. Mutual Contact Creation
            // My contact document (me -> sender)
            batch.set(doc(db, `users/${currentUser.uid}/contacts`, targetUid), {
                uid: targetUid,
                name: senderData.senderName,
                isFriend: true,
                lastMessage: 'Accepted friend request.',
                unread: false,
                timestamp: serverTimestamp()
            });

            // Sender's contact document (sender -> me)
            const senderUserDoc = await getDoc(doc(db, 'users', targetUid));
            const senderName = senderUserDoc.data()?.name || myPublicId;

            batch.set(doc(db, `users/${targetUid}/contacts`, currentUser.uid), {
                uid: currentUser.uid,
                name: myPublicName,
                isFriend: true,
                lastMessage: 'Accepted friend request.',
                unread: false,
                timestamp: serverTimestamp()
            });
            
            // 3. Mutual Request Deletion
            // Delete my incoming request
            batch.delete(doc(db, `users/${currentUser.uid}/requests`, targetUid));
            // Delete sender's outgoing request
            batch.delete(doc(db, `users/${targetUid}/requests`, currentUser.uid));

            await batch.commit();
            console.log(`Accepted request from ${targetUid}`);
        }

        async function removeRequest(targetUid, isOutgoing) {
            const batch = writeBatch(db);
            
            // If it's an incoming request (I am denying)
            if (!isOutgoing) {
                // Delete my incoming request
                batch.delete(doc(db, `users/${currentUser.uid}/requests`, targetUid));
                // Delete the sender's outgoing request
                batch.delete(doc(db, `users/${targetUid}/requests`, currentUser.uid));
            } 
            // If it's an outgoing request (I am cancelling)
            else {
                // Delete my outgoing request
                batch.delete(doc(db, `users/${currentUser.uid}/requests`, targetUid));
                // Delete the recipient's incoming request
                batch.delete(doc(db, `users/${targetUid}/requests`, currentUser.uid));
            }

            await batch.commit();
            console.log(`Request removed for ${targetUid}`);
        }

        // --- CHAT FUNCTIONS ---

        function scrollToBottom() {
            setTimeout(() => {
                dom.messagesContainerEl.scrollTop = dom.messagesContainerEl.scrollHeight;
            }, 0); 
        }

        async function openChat(uid, name) {
            if (currentChatPartner?.uid === uid) return; // Already open

            currentChatPartner = { uid, name };
            dom.chatHeaderEl.textContent = name;
            dom.messagesContainerEl.innerHTML = '';
            dom.chatPlaceholder.classList.add('hidden');
            lastMessageCount = 0; // Reset message count for new chat

            // Mobile-specific view change
            if (window.innerWidth < 640) {
                dom.contactsView.classList.add('view-hidden');
                dom.chatView.classList.remove('view-hidden');
            }
            dom.messageInput.focus();
            
            listenForMessages(uid);
            
            // Mark unread as read in contacts list
            const contactRef = doc(db, `users/${currentUser.uid}/contacts`, uid);
            try { 
                await updateDoc(contactRef, { unread: false });
            } catch (e) { 
                console.log("Contact not found for unread update, likely new chat.");
            }
        }

        function closeChat() {
            unsubscribeMessages();
            currentChatPartner = null;
            // Mobile-specific view change
            dom.chatView.classList.add('view-hidden');
            dom.contactsView.classList.remove('view-hidden');
            // Clear message list
            dom.messagesContainerEl.innerHTML = '';
            dom.chatPlaceholder.classList.remove('hidden');
        }

        function listenForMessages(chatPartnerId = currentChatPartner?.uid) {
            unsubscribeMessages();
            if (!chatPartnerId) return;

            const chatId = getChatId(currentUser.uid, chatPartnerId);
            const chatDocRef = doc(db, 'chats', chatId);
            
            unsubscribeMessages = onSnapshot(chatDocRef, (doc) => {
                if (!doc.exists()) {
                    dom.messagesContainerEl.innerHTML = `<div class="p-4 text-center text-gray-500 font-thin">Start your conversation!</div>`;
                    lastMessageCount = 0;
                    return;
                }
                const data = doc.data();
                const allMessages = data.messages || [];

                // Filter out messages blocked users may have sent
                const filteredMessages = allMessages.filter(msg => 
                    msg.senderId === currentUser.uid || !blockedUsers.includes(msg.senderId)
                );

                // --- Message Rendering Logic ---
                // Only take the last MESSAGE_LIMIT messages
                const messagesToDisplay = filteredMessages.slice(-MESSAGE_LIMIT);

                // Find the timestamps of the last 3 *sent* messages that have been marked as seen
                const sentMessages = filteredMessages.filter(msg => msg.senderId === currentUser.uid);
                const last3SeenTimestamps = sentMessages
                    .filter(msg => msg.seen)
                    .slice(-3) // Take the last 3 seen messages
                    .map(msg => msg.timestamp?.toDate ? msg.timestamp.toDate().toISOString() : new Date(msg.timestamp).toISOString());

                // --- NEW: Auto-scroll control (only scrolls if message count increases) ---
                const currentMessageCount = messagesToDisplay.length;
                const shouldScroll = currentMessageCount > lastMessageCount;
                lastMessageCount = currentMessageCount; // Update count for next time

                dom.messagesContainerEl.innerHTML = '';
                messagesToDisplay.forEach(msg => renderMessage(msg, last3SeenTimestamps));
                
                setupSeenObserver(messagesToDisplay);
                
                if (shouldScroll) {
                    scrollToBottom();
                }
            });
        }


        function renderMessage(data, last3SeenTimestamps = []) {
            if (!data || (!data.text && (!data.images || data.images.length === 0))) return;
            
            const messageWrapper = document.createElement('div');
            const isSent = data.senderId === currentUser.uid;
            let time = '';
            let timestampISO = '';

            if (data.timestamp?.toDate) {
                const date = data.timestamp.toDate();
                time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                timestampISO = date.toISOString();
            } else if (data.timestamp) {
                const date = new Date(data.timestamp);
                time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                timestampISO = date.toISOString();
            }
            
            // --- NEW: Message Truncation/Expansion Logic ---
            const isLargeMessage = data.text && data.text.length > MESSAGE_TRUNCATE_LENGTH;
            // Always render the full text, let CSS handle truncation
            const displayText = data.text; 
            
            const messageContentClasses = isLargeMessage ? 'message-content truncated' : 'message-content';

            // Check if this message is one of the last 3 seen messages
            const isSeen = last3SeenTimestamps.includes(timestampISO);

            const bubbleClasses = isSent ? 'sent-bubble' : 'received-bubble';

            let imagesHTML = '';
            if (data.images && data.images.length > 0) {
                imagesHTML = `
                    <div class="image-attachment-grid">
                        ${data.images.map(url => `
                            <img src="${url}" class="image-attachment" data-action="view-image">
                        `).join('')}
                    </div>
                `;
            }

            // MODIFIED: Added Show More/Show Less text to the arrow button
            const fadeArrowHTML = isLargeMessage ? `
                <div class="fade-arrow" data-action="toggle-expand">
                    <span data-state="collapsed">Show More</span>
                    <span data-state="expanded" class="hidden">Show Less</span>
                    <i class="fa-solid fa-chevron-down w-3 h-3"></i>
                </div>
            ` : '';

            // MODIFIED: Added responsive Tailwind max-width classes
            messageWrapper.className = `flex ${isSent ? 'justify-end' : 'justify-start'} message-wrapper my-3`;
            messageWrapper.dataset.timestamp = timestampISO;
            messageWrapper.innerHTML = `
                <div data-timestamp="${timestampISO}" data-seen="${data.seen ? 'true' : 'false'}" 
                     class="message-bubble ${bubbleClasses} ${!data.seen && !isSent ? 'unread-message' : ''} max-w-xs md:max-w-md lg:max-w-lg" 
                     data-action="toggle-expand"> 
                    
                    <div class="${messageContentClasses}">
                        ${displayText ? `<p class="message-text">${displayText}</p>` : ''}
                        ${data.images && data.images.length > 0 && !isLargeMessage ? imagesHTML : ''}
                        ${fadeArrowHTML}
                    </div>

                    ${data.images && data.images.length > 0 && isLargeMessage ? imagesHTML : ''}
                </div>
            `;
            
            // Insert timestamp below the bubble
            const timestampEl = document.createElement('div');
            timestampEl.className = `message-timestamp ${isSent ? 'text-right' : 'text-left'}`;
            timestampEl.innerHTML = `
                ${time}
                ${isSent ? `<span class="seen-status">${isSeen ? '  Seen' : ''}</span>` : ''}
            `;

            dom.messagesContainerEl.appendChild(messageWrapper);
            dom.messagesContainerEl.appendChild(timestampEl);
        }

        // --- SEEN STATUS LOGIC ---

        function setupSeenObserver(messages) {
            if (!currentChatPartner) return;

            // Stop observing all previous targets
            if (window.seenObserver) {
                window.seenObserver.disconnect();
            }

            // Filter for unread *received* messages
            const unreadReceivedMessages = messages.filter(msg => 
                msg.senderId === currentChatPartner.uid && !msg.seen
            );

            if (unreadReceivedMessages.length === 0) return;

            // Get the corresponding DOM elements
            const unreadElements = Array.from(dom.messagesContainerEl.querySelectorAll('.unread-message'));

            window.seenObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
                        const messageElement = entry.target.closest('.message-bubble');
                        const timestampISO = messageElement.dataset.timestamp;

                        // Use a timeout to simulate a delay before marking seen
                        setTimeout(() => {
                            // Check again if it's still visible and hasn't been marked seen by another process
                            if (messageElement.dataset.seen !== 'true') {
                                handleSeenUpdate(timestampISO);
                                window.seenObserver.unobserve(messageElement);
                            }
                        }, SEEN_DELAY_MS);
                    }
                });
            }, {
                root: dom.messagesContainerEl,
                threshold: 0.5, // Trigger when 50% of the target is visible
            });

            // Start observing all unread received messages
            unreadElements.forEach(el => window.seenObserver.observe(el));
        }

        async function handleSeenUpdate(timestampISO) {
            if (!currentChatPartner) return;
            const chatId = getChatId(currentUser.uid, currentChatPartner.uid);
            const chatDocRef = doc(db, 'chats', chatId);

            try {
                // The transaction will read the current messages array, update the one matching the timestamp, and write it back
                const docSnap = await getDoc(chatDocRef);
                if (docSnap.exists()) {
                    const messages = docSnap.data().messages || [];
                    
                    const updatedMessages = messages.map(msg => {
                        // Normalize timestamp for comparison (Firestore Timestamp vs ISO string from DOM)
                        let msgTimestampISO = msg.timestamp?.toDate ? msg.timestamp.toDate().toISOString() : new Date(msg.timestamp).toISOString();
                        
                        if (msgTimestampISO === timestampISO && msg.senderId === currentChatPartner.uid && !msg.seen) {
                            return { ...msg, seen: true };
                        }
                        return msg;
                    });
                    
                    // Only update if changes were made
                    if (messages.length !== updatedMessages.length || JSON.stringify(messages) !== JSON.stringify(updatedMessages)) {
                         await updateDoc(chatDocRef, { messages: updatedMessages });
                    }
                }
            } catch (error) {
                console.error("Error updating seen status:", error);
            }
        }

        // --- MESSAGE SENDING ---

        async function handleSendMessage(e) {
            if (e) e.preventDefault();
            
            if (!currentChatPartner) {
                alert("Please select a friend to chat with first.");
                return;
            }

            const text = dom.messageInput.value.trim();
            const images = imageAttachmentsBase64;
            
            if (text === '' && images.length === 0) {
                return; // Do nothing if both are empty
            }

            // 1. Upload Images to Firebase Storage (if any)
            let imageUrls = [];
            if (images.length > 0) {
                dom.sendBtn.disabled = true;
                dom.sendBtn.innerHTML = `<i class="fa-solid fa-spinner fa-spin w-5 h-5"></i>`; // Loading spinner

                try {
                    const uploadPromises = images.map((base64String, index) => {
                        const filename = `${currentUser.uid}_${Date.now()}_${index}.png`;
                        const imgRef = storageRef(storage, `chat_images/${currentChatPartner.uid}/${filename}`);
                        // Use base64 string directly
                        return uploadString(imgRef, base64String, 'data_url')
                            .then(snapshot => getDownloadURL(snapshot.ref));
                    });
                    imageUrls = await Promise.all(uploadPromises);
                } catch (error) {
                    console.error("Image upload failed:", error);
                    alert("Failed to upload image(s). Message not sent.");
                    dom.sendBtn.disabled = false;
                    dom.sendBtn.innerHTML = icons.send;
                    return;
                }
            }

            // 2. Write Message to Chat
            await writeMessageToChat(text, imageUrls);

            // 3. Clear UI
            dom.messageInput.value = '';
            imageAttachmentsBase64 = [];
            dom.imageInput.value = ''; // Clear file input
            dom.imagePreviewContainer.innerHTML = '';
            dom.imagePreviewContainer.classList.add('hidden');
            dom.sendBtn.innerHTML = icons.send;
            dom.sendBtn.disabled = false;
            
            // NEW: Reset textarea height
            dom.messageInput.style.height = 'auto'; 
            autoExpandTextarea(dom.messageInput);
        }
        
        async function writeMessageToChat(text, imageUrls) {
            const chatId = getChatId(currentUser.uid, currentChatPartner.uid);
            const chatDocRef = doc(db, 'chats', chatId);
            
            const messageData = {
                senderId: currentUser.uid,
                text: text,
                images: imageUrls,
                timestamp: serverTimestamp(),
                seen: false
            };
            
            try {
                // Check if chat document exists to decide whether to use setDoc or updateDoc
                const chatSnap = await getDoc(chatDocRef);
                const messageUpdate = {
                    messages: arrayUnion(messageData),
                };

                if (chatSnap.exists()) {
                    await updateDoc(chatDocRef, messageUpdate);
                } else {
                    await setDoc(chatDocRef, messageUpdate);
                }

                // 4. Update both users' contact lists (Last Message & Unread status)
                const lastMessageText = text || 'Sent image(s)';
                const myContactRef = doc(db, `users/${currentUser.uid}/contacts`, currentChatPartner.uid);
                const partnerContactRef = doc(db, `users/${currentChatPartner.uid}/contacts`, currentUser.uid);

                const batch = writeBatch(db);

                // My side: Update last message
                batch.update(myContactRef, { 
                    lastMessage: lastMessageText,
                    timestamp: serverTimestamp(),
                });

                // Partner side: Update last message and set unread to true
                batch.update(partnerContactRef, { 
                    lastMessage: lastMessageText,
                    unread: true,
                    timestamp: serverTimestamp(),
                });

                await batch.commit();

            } catch (error) {
                console.error("Error writing message or updating contacts:", error);
                alert("Failed to send message and/or update contacts.");
            }
        }
        
        // --- IMAGE ATTACHMENT LOGIC ---
        
        function handleImageUpload(e) {
            const files = e.target.files;
            if (files.length === 0) return;

            // Clear previous attachments only if new files are selected
            imageAttachmentsBase64 = [];
            dom.imagePreviewContainer.innerHTML = '';
            dom.imagePreviewContainer.classList.add('hidden');

            Array.from(files).slice(0, 5).forEach(file => { // Limit to 5 images
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const base64 = event.target.result;
                        imageAttachmentsBase64.push(base64);
                        renderImagePreview(base64);
                        dom.sendBtn.innerHTML = icons.send; // Ensure send icon is active
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function renderImagePreview(base64) {
            dom.imagePreviewContainer.classList.remove('hidden');
            const previewItem = document.createElement('div');
            previewItem.className = 'image-preview-item';
            previewItem.dataset.base64 = base64; // Store base64 for removal

            previewItem.innerHTML = `
                <img src="${base64}" alt="Image preview" class="w-full h-full object-cover">
                <button class="remove-image-btn" data-action="remove-image">&times;</button>
            `;
            dom.imagePreviewContainer.appendChild(previewItem);
        }

        function handleRemoveImage(e) {
            const btn = e.target.closest('[data-action="remove-image"]');
            if (!btn) return;

            const item = btn.closest('.image-preview-item');
            const base64ToRemove = item.dataset.base64;

            // Remove from array
            imageAttachmentsBase64 = imageAttachmentsBase64.filter(b => b !== base64ToRemove);

            // Remove from DOM
            item.remove();

            // Hide container if empty
            if (imageAttachmentsBase64.length === 0) {
                dom.imagePreviewContainer.classList.add('hidden');
                if (dom.messageInput.value.trim() === '') {
                    // Update send button if message is also empty
                    dom.sendBtn.innerHTML = icons.check; 
                }
            }
            // Ensure the file input itself is cleared so re-uploading the same file works
            dom.imageInput.value = '';
        }

        // --- UI EVENT HANDLERS ---
        
        function handleMessageClick(e) {
            // Find the closest parent element that is the message bubble or the fade arrow
            let target = e.target.closest('[data-action="toggle-expand"]');
            
            // If the user clicks on the image itself, ignore this handler
            if (e.target.closest('[data-action="view-image"]')) return;

            const bubble = e.target.closest('.message-bubble');
            if (!bubble) return;

            // If the click happened on the arrow button OR the bubble itself (when truncated)
            if (target || bubble.querySelector('.message-content.truncated')) {
                const content = bubble.querySelector('.message-content');
                if (!content) return;

                // This toggles the 'truncated' class on the content div
                const isTruncated = content.classList.toggle('truncated');
                
                // Toggle the 'expanded' class on the arrow wrapper
                const arrow = bubble.querySelector('.fade-arrow');
                if (arrow) {
                    arrow.classList.toggle('expanded', !isTruncated);
                    
                    // Toggle the 'Show More' / 'Show Less' text for better UX
                    const collapsedText = arrow.querySelector('[data-state="collapsed"]');
                    const expandedText = arrow.querySelector('[data-state="expanded"]');
                    
                    if (isTruncated) {
                        collapsedText.classList.remove('hidden');
                        expandedText.classList.add('hidden');
                    } else {
                        collapsedText.classList.add('hidden');
                        expandedText.classList.remove('hidden');
                    }
                    
                    // Re-calculate scroll position after expansion/collapse
                    scrollToBottom();
                }
            }
        }

        async function handleCopyId() {
            if (!navigator.clipboard) {
                // Using document.execCommand as a fallback for iframe environments
                const textArea = document.createElement("textarea");
                textArea.value = dom.myIdEl.textContent;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    dom.copyIdBtn.textContent = 'Copied!';
                    setTimeout(() => { dom.copyIdBtn.textContent = 'Copy'; }, 2000);
                } catch (err) {
                    console.error('Fallback copy: ', err);
                }
                document.body.removeChild(textArea);
                return;
            }
            
            try {
                await navigator.clipboard.writeText(dom.myIdEl.textContent);
                dom.copyIdBtn.textContent = 'Copied!';
                setTimeout(() => { dom.copyIdBtn.textContent = 'Copy'; }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        function handleTabClick(e) {
            const target = e.target.closest('button');
            if (!target) return;

            const isFriends = target.id === 'tab-btn-friends';

            // Toggle button styles
            dom.tabBtnFriends.className = isFriends ? 'btn-themed-primary flex-1' : 'btn-themed-secondary flex-1';
            dom.tabBtnRequests.className = isFriends ? 'btn-themed-secondary flex-1' : 'btn-themed-primary flex-1';

            // Toggle content visibility
            dom.tabContentFriends.classList.toggle('hidden', !isFriends);
            dom.tabContentRequests.classList.toggle('hidden', isFriends);
        }

        async function handleClearLocalChat() {
            if (!currentChatPartner) {
                alert("Please select a chat to clear its local history.");
                return;
            }
            const partnerName = currentChatPartner.name;
            const confirmation = confirm(`Are you sure you want to clear the local chat history with ${partnerName}? This action is irreversible.`);
            
            if (confirmation) {
                // Clearing local history means deleting the chat document entirely
                const chatId = getChatId(currentUser.uid, currentChatPartner.uid);
                const chatDocRef = doc(db, 'chats', chatId);

                try {
                    await deleteDoc(chatDocRef);
                    alert(`Chat history with ${partnerName} cleared successfully!`);
                    // This will trigger listenForMessages to re-render the empty chat
                } catch (error) {
                    console.error("Error clearing chat history:", error);
                    alert("Failed to clear chat history. Please check console for details.");
                }
            }
        }

        // --- STATUS & TIME ---

        function updateStatus() {
            // Update time
            dom.localTimeEl.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            // Update battery (if supported)
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    dom.batteryStatusEl.textContent = `${Math.round(battery.level * 100)}%`;
                });
            } else {
                dom.batteryStatusEl.textContent = `N/A`;
            }
        }

        function startStatusUpdates() {
            updateStatus();
            if (statusInterval) clearInterval(statusInterval);
            statusInterval = setInterval(updateStatus, 5000);
        }

        function stopStatusUpdates() {
            if (statusInterval) clearInterval(statusInterval);
        }

        // --- INITIAL SETUP ---

        function setupEventListeners() {
            dom.copyIdBtn.addEventListener('click', handleCopyId);
            dom.addContactBtn.addEventListener('click', handleAddContact);
            dom.friendsListEl.addEventListener('click', handleContactsListClick);
            
            dom.tabBtnFriends.addEventListener('click', handleTabClick);
            dom.tabBtnRequests.addEventListener('click', handleTabClick);
            
            dom.tabContentRequests.addEventListener('click', handleRequestAction);
            dom.backToContactsBtn.addEventListener('click', closeChat);
            dom.messageForm.addEventListener('submit', handleSendMessage);
            
            dom.messagesContainerEl.addEventListener('click', handleMessageClick);
            
            dom.lccBtn.addEventListener('click', handleClearLocalChat);

            // --- NEW: Textarea & Send Button Logic ---
            dom.messageInput.addEventListener('input', () => {
                autoExpandTextarea(dom.messageInput); // Call auto-expand logic
                if (dom.messageInput.value.trim() !== '' || imageAttachmentsBase64.length > 0) {
                    dom.sendBtn.innerHTML = icons.send;
                } else {
                    dom.sendBtn.innerHTML = icons.check; 
                }
            });
            
            // Keydown Listener for Enter/Shift+Enter logic
            dom.messageInput.addEventListener('keydown', (e) => {
                // If the user presses Enter (key code 13)
                if (e.key === 'Enter') {
                    // If Shift is NOT held, send the message
                    if (!e.shiftKey) {
                        e.preventDefault(); // Prevent default new line behavior
                        if (dom.messageInput.value.trim() !== '' || imageAttachmentsBase64.length > 0) {
                             handleSendMessage(); // Call the send function
                        }
                    } else {
                        // If Shift IS held, allow the new line, and adjust the textarea size
                        setTimeout(() => autoExpandTextarea(dom.messageInput), 0); // Delay to allow the newline character to register
                    }
                }
            });
            
            // --- NEW: Image Listeners ---
            dom.attachImageBtn.addEventListener('click', () => dom.imageInput.click());
            dom.imageInput.addEventListener('change', handleImageUpload);
            dom.imagePreviewContainer.addEventListener('click', handleRemoveImage);
        }

        // --- START THE APP ---
        main();
    </script>
</body>
</html>
