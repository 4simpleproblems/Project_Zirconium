<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4SP - Messenger V2</title>
    <meta name="description" content="A secure, peer-to-peer messenger with group chat functionality, image sharing, and hybrid message storage.">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* --- FONT & BASE STYLING --- */
        :root {
            --padding-base: 1.25rem; /* Increased base padding */
        }
        body { 
            font-family: 'Geist', sans-serif; 
            background-color: #070707; 
            color: #c0c0c0; 
            transition: all 0.3s ease;
            font-weight: 300; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        h1, h2, h3, .font-bold, .font-semibold, strong, .tracking-widest {
            font-weight: 400 !important; 
        }

        /* Responsive Container */
        .messenger-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 1rem; /* Increased gap for better spacing */
            max-width: 1600px; 
            margin: 0 auto;    
            width: 100%; 
            height: 100vh;
            padding: 1rem; /* Increased padding */
            box-sizing: border-box;
        }
        @media (max-width: 1024px) {
             .messenger-container {
                grid-template-columns: 1fr;
                gap: 0;
             }
             .left-panel {
                display: none; /* Hide left panel on smaller screens by default, rely on back button */
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                z-index: 30;
                height: 100vh;
                border-radius: 0;
             }
             .left-panel.active {
                display: flex;
             }
             #chat-view {
                border-radius: 0;
             }
             #back-to-chats-btn {
                display: flex !important; /* Always show back button on mobile */
             }
             
        }


        /* Panel Styling */
        .left-panel, .right-panel { 
            background-color: #111111; 
            border: 1px solid #252525; 
            border-radius: 1rem;
            padding: var(--padding-base); 
            display: flex;
            flex-direction: column;
            max-height: 100%;
        }
        
        /* Friend Code Input Styling */
        .friend-code-input-styled {
            background-image: linear-gradient(to right, #252525 0%, #252525 90%);
            background-size: 12.5% 2px; 
            background-repeat: repeat-x;
            background-position: 0 90%;
            letter-spacing: 0.5rem !important; 
            padding-left: 0.75rem !important;
            padding-right: 0.75rem !important;
            border: none !important;
            box-shadow: none !important;
        }
        .friend-code-input-styled:focus {
             background-image: linear-gradient(to right, #4f46e5 0%, #4f46e5 90%);
        }
        
        /* Compact List Styling */
        .compact-list-wrapper {
             background-color: #0d0d0d; 
             border-radius: 0.75rem;
             padding: 0.25rem 0.5rem; 
             border: 1px solid #1a1a1a;
             margin-top: 0.75rem;
             flex-grow: 1;
             overflow: hidden;
             display: flex;
             flex-direction: column;
        }
        .compact-list-items {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 0.25rem; 
        }
        
        /* Custom scrollbar */
        .compact-list-items::-webkit-scrollbar, .chat-messages::-webkit-scrollbar { width: 8px; }
        .compact-list-items::-webkit-scrollbar-thumb, .chat-messages::-webkit-scrollbar-thumb { background-color: #4f46e5; border-radius: 4px; }
        .compact-list-items::-webkit-scrollbar-track, .chat-messages::-webkit-scrollbar-track { background-color: #1f2937; }

        /* List Item Styling */
        .compact-list-item {
            background-color: transparent; 
            border-radius: 0.5rem;
            margin-bottom: 0.25rem;
            padding: 0.75rem 0.75rem; /* Increased padding */
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .compact-list-item:hover {
            background-color: #1f1f1f;
        }
        .compact-list-item.active {
            background-color: #1a1a2e;
            border-left: 3px solid #4f46e5;
        }
        .compact-list-item [data-action="open-chat"] {
            cursor: pointer;
        }

        /* Dynamic Control Transitions */
        .tab-btn.active {
            background-color: #4f46e5;
            color: #fff;
        }
        
        /* Fade in/out control for dynamic elements */
        #add-friend-section, #group-chat-controls {
            transition: opacity 0.3s ease-in-out;
        }
        .fade-out {
            opacity: 0; height: 0; overflow: hidden;
            padding-top: 0 !important; padding-bottom: 0 !important;
            border-color: transparent !important;
        }
        .fade-in { opacity: 1; height: auto; }

        /* Modal & Lightbox Styling (Updated for image expansion) */
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darkened background */
            display: flex;
            z-index: 50; transition: opacity 0.3s ease;
        }
        .modal-content {
            background-color: #111111; border: 1px solid #252525; 
            border-radius: 1rem; padding: 1.5rem; max-width: 500px; width: 100%;
            margin: auto; /* Center content */
        }
        #image-lightbox img {
            max-width: 90%; /* Maximize image size */
            max-height: 90vh;
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        /* General input styling */
        input, textarea {
            font-weight: 300 !important; background-color: #0d0d0d;
            border: 1px solid #252525; border-radius: 0.5rem;
            padding: 0.75rem; color: #c0c0c0; transition: all 0.2s ease;
        }
        input:focus, textarea:focus {
            outline: none; border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5);
        }
        textarea {
            padding-right: 1.25rem; /* Space for scrollbar */
        }

        /* Message Container */
        .chat-messages {
            display: flex; flex-direction: column;
            overflow-y: auto; flex-grow: 1;
            padding: 1rem; position: relative;
        }
        .chat-messages > .message-wrapper { 
            margin-bottom: 0.5rem; /* Tighter spacing */
            max-width: 85%; /* Enforce width for better look */
        }
        
        /* Message Link Styling */
        .message-content a {
            color: #60a5fa; /* Tailwind's blue-400 */
            text-decoration: underline;
        }
        .message-content a:hover {
            text-decoration: none;
        }

        /* File Preview Container */
        #file-preview-container {
            max-height: 120px; overflow-x: auto; overflow-y: hidden;
            white-space: nowrap; padding: 0.5rem 0;
            border-top: 1px solid #252525; margin-top: 0.5rem;
        }
        .file-preview {
            display: inline-block; position: relative;
            margin-right: 0.5rem; border: 1px solid #4f46e5;
            border-radius: 0.5rem; overflow: hidden;
            width: 100px; height: 100px;
            background-color: #0d0d0d; text-align: center;
        }
        .file-preview img { width: 100%; height: 100%; object-fit: cover; }
        .file-preview .remove-file-btn {
            position: absolute; top: 2px; right: 2px;
            background: rgba(255, 0, 0, 0.7); color: white;
            border-radius: 50%; width: 20px; height: 20px;
            font-size: 10px; line-height: 20px; text-align: center;
            cursor: pointer;
        }

        /* Character Limit Display - Moved outside text area */
        #char-limit-display {
            font-size: 0.75rem;
            color: #6b7280;
            text-align: right;
            height: 1rem;
            padding-right: 0.25rem;
        }
        
        /* Read Receipt Visuals */
        .message-read-indicator {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            opacity: 0; transform: scale(0.9);
        }
        .message-read-indicator.visible { opacity: 1; transform: scale(1); }
        .message-read-indicator .fa-eye { color: #4f46e5; }
        .message-read-indicator .fa-eye-slash { color: #6b7280; }
        
        /* Message Expansion/Truncation */
        .message-truncated .message-content {
            max-height: 4.5em; /* Approximately 3 lines for truncation */
            overflow: hidden;
            position: relative;
        }
        .message-truncated .message-content::after {
            content: "";
            position: absolute;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 1.5em;
            background: linear-gradient(to top, rgba(17, 17, 17, 1), rgba(17, 17, 17, 0));
        }
        .message-expanded .message-content {
            max-height: none;
            overflow: visible;
        }
        .message-expanded .message-content::after {
            display: none;
        }

        /* New: Pseudo File Menu */
        #file-menu {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 0;
            background-color: #1f1f1f;
            border: 1px solid #252525;
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 20;
        }
        #file-menu button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        #file-menu button:hover {
            background-color: #252525;
        }
        
        /* Reactions/Context Menu (Simple implementation) */
        .message-options {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: none; /* Hidden by default */
            z-index: 10;
        }
        .message-wrapper:hover .message-options {
            display: flex;
        }
        .message-wrapper.justify-end .message-options {
            left: -32px; /* Position to the left of my message */
        }
        .message-wrapper.justify-start .message-options {
            right: -32px; /* Position to the right of partner's message */
        }

    </style>
</head>
<body>

    <div id="image-lightbox" class="modal-backdrop hidden opacity-0 items-center justify-center p-4 cursor-pointer">
        <img id="lightbox-image" src="" alt="Enlarged view" class="max-w-full max-h-full object-contain rounded-lg">
    </div>

    <div id="create-group-modal" class="modal-backdrop hidden opacity-0">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4 text-white">Create New Group</h3>
            <form id="create-group-form" class="flex flex-col gap-4">
                <input type="text" id="group-name-input" placeholder="Enter Group Name" required maxlength="50">
                <div class="border-y border-gray-800 py-2">
                    <h4 class="font-semibold mb-2 text-gray-300">Select Friends (Max 20)</h4>
                    <div id="group-members-list" class="max-h-60 overflow-y-auto space-y-2 pr-2">
                        <p class="text-gray-500 text-center">Loading friends...</p>
                    </div>
                </div>
                <button type="submit" class="px-4 py-2 bg-indigo-600 rounded-lg hover:bg-indigo-700 transition font-semibold w-full">Create Group</button>
            </form>
            <button id="create-group-modal-close-btn" class="mt-3 text-sm text-gray-400 hover:text-white w-full">Cancel</button>
        </div>
    </div>

    <div id="settings-modal" class="modal-backdrop hidden opacity-0">
        <div class="modal-content max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-white border-b border-gray-800 pb-3">Application Settings</h3>
            <section id="blocked-users-section" class="mt-4">
                <h4 class="font-semibold mb-3 text-gray-300">Blocked Users</h4>
                <div id="blocked-users-list" class="max-h-80 overflow-y-auto space-y-2 pr-2">
                    <p class="text-gray-500 text-sm p-2">Loading blocked users...</p>
                </div>
            </section>
            <button id="settings-modal-close-btn" class="mt-6 px-4 py-2 bg-gray-600 rounded-lg hover:bg-gray-700 transition font-semibold w-full">Close</button>
        </div>
    </div>

    <div id="confirm-modal" class="modal-backdrop hidden opacity-0">
        <div class="modal-content max-w-sm text-center">
            <h3 id="confirm-modal-title" class="text-xl font-bold mb-3 text-white">Are you sure?</h3>
            <p id="confirm-modal-body" class="mb-6 text-gray-300">This action cannot be undone.</p>
            <div class="flex justify-center gap-4">
                <button id="confirm-modal-yes-btn" class="px-5 py-2 bg-red-600 rounded-lg hover:bg-red-700 font-semibold">Yes</button>
                <button id="confirm-modal-no-btn" class="px-5 py-2 bg-gray-600 rounded-lg hover:bg-gray-700 font-semibold">No</button>
            </div>
        </div>
    </div>
    
    <div id="file-menu" class="hidden">
        <button id="file-menu-image-btn">
            <i class="fas fa-image"></i><span>Photo Library</span>
        </button>
        <button id="file-menu-camera-btn">
            <i class="fas fa-camera"></i><span>Take Photo</span>
        </button>
    </div>
    <main id="app-ui" class="messenger-container" style="display: none;">
        
        <aside class="left-panel" id="left-panel">
            <div class="mb-4 border-b border-gray-800 pb-4 flex justify-between items-start">
                <div>
                    <div id="current-time-display" class="text-3xl font-bold text-left text-indigo-400 mb-2 font-mono">--:--:--</div>
                    <p class="text-sm text-left text-gray-500">My Code: <span id="my-id-display" class="font-mono text-gray-400">...</span></p>
                </div>
                <button id="open-settings-btn" class="mt-1 w-10 h-10 flex items-center justify-center rounded-full text-gray-400 hover:bg-gray-800 transition-colors flex-shrink-0" title="Settings">
                    <i class="fas fa-cog text-xl"></i>
                </button>
            </div>
            
            <div class="flex mb-3 rounded-lg bg-gray-900 border border-gray-800 p-1">
                <button id="chats-tab-btn" data-tab="chats" class="tab-btn flex-1 py-2 text-center rounded-lg font-semibold bg-indigo-600 text-white transition">
                    <i class="fas fa-comments mr-2"></i>Chats
                </button>
                <button id="friends-tab-btn" data-tab="friends" class="tab-btn flex-1 py-2 text-center rounded-lg font-semibold text-gray-400 hover:bg-gray-800 transition">
                    <i class="fas fa-user-friends mr-2"></i>Friends
                </button>
            </div>

            <div id="dynamic-controls" class="mb-4 pb-4 flex flex-col gap-4"> 
                <div id="add-friend-section" class="fade-out" style="display: none;">
                    <h2 class="text-xl font-bold mb-2">Add a Friend</h2>
                    <form id="add-friend-form" class="flex gap-2">
                        <input type="text" id="add-friend-id-input" placeholder="abcdef12" maxlength="8" class="friend-code-input-styled flex-grow bg-transparent tracking-widest text-center" style="font-family: monospace;" title="Enter friend's 8-character code">
                        <button type="submit" class="px-3 py-2 bg-indigo-600 rounded-md hover:bg-indigo-700 transition font-semibold" title="Send Friend Request">
                            <i class="fas fa-user-plus"></i>
                        </button>
                    </form>
                    <div id="add-friend-message" class="text-sm mt-2 min-h-[20px]"></div>
                </div>

                <div class="flex justify-between items-center fade-in" id="group-chat-controls">
                    <h2 class="text-xl font-bold">Chats</h2>
                    <button id="create-group-btn" class="text-indigo-400 hover:text-indigo-500 transition px-2 py-1" title="Create New Group">
                        <i class="fas fa-users"></i> New Group
                    </button>
                </div>
            </div>
            
            <div class="flex-grow flex flex-col min-h-0">
                <div id="friend-requests-section" class="mb-4"></div>
                <div id="list-wrapper" class="compact-list-wrapper">
                    <div id="active-list-items" class="compact-list-items">
                        <p class="p-4 text-center text-gray-500">Loading...</p>
                    </div>
                </div>
            </div>
        </aside>

        <section id="chat-view" class="right-panel hidden relative">
            <header class="pb-3 border-b border-gray-800 flex items-center justify-between flex-shrink-0">
                <div class="flex items-center gap-3">
                    <button id="back-to-chats-btn" class="w-8 h-8 flex items-center justify-center rounded-full text-gray-400 hover:bg-gray-800 transition-colors lg:hidden" style="display:none;" title="Back to Chats">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <h1 id="chat-header" class="text-2xl font-bold">Select a Chat</h1>
                </div>
                <div class="flex items-center gap-4">
                    <button id="edit-label-btn" class="hidden text-gray-400 hover:text-white transition" title="Edit Local Nickname">
                        <i class="fas fa-tag"></i>
                    </button>
                    <button id="manage-group-nicknames-btn" class="hidden text-gray-400 hover:text-white transition" title="Manage Group Nicknames">
                        <i class="fas fa-address-book"></i>
                    </button>
                    <button id="edit-group-name-btn" class="hidden text-gray-400 hover:text-white transition" title="Edit Group Name">
                        <i class="fas fa-pencil-alt"></i>
                    </button>
                    <button id="clear-chat-btn" class="hidden text-gray-400 hover:text-white transition" title="Clear All Messages (Local Only)">
                        <i class="fas fa-broom"></i>
                    </button>
                    <button id="block-user-btn" class="hidden text-red-400 hover:text-red-500 transition" title="Block User">
                        <i class="fas fa-user-slash"></i>
                    </button>
                </div>
            </header>
            
            <div class="chat-messages p-4 my-4" id="messages-container">
                 <div class="flex justify-center items-center h-full">
                    <p class="text-gray-500">Select a chat from the left to start messaging.</p>
                </div>
            </div>
            
            <button id="scroll-to-bottom-btn" class="hidden fixed bottom-28 right-8 w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-indigo-700 transition z-10" title="Scroll to newest message">
                <i class="fas fa-arrow-down"></i>
            </button>

            <footer class="pt-4 border-t border-gray-800 flex-shrink-0">
                <div id="file-preview-container" class="hidden"></div>
                <form id="message-form" class="flex gap-3 items-end">
                    <button type="button" id="open-file-menu-btn" class="w-12 h-12 flex items-center justify-center bg-gray-800 text-gray-400 rounded-lg hover:bg-gray-700 transition cursor-pointer flex-shrink-0 relative" title="Attach Files">
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <input type="file" id="file-upload-input" multiple accept="image/*" class="hidden">
                    <input type="file" id="camera-capture-input" accept="image/*" capture="camera" class="hidden">
                    
                    <div class="relative w-full flex flex-col">
                        <textarea id="message-input" placeholder="Type a message..." class="w-full h-12 resize-none flex-grow" autocomplete="off"></textarea>
                        <div id="char-limit-display"></div>
                    </div>
                    
                    <button type="submit" id="send-btn" class="w-12 h-12 flex-shrink-0 bg-indigo-600 text-white rounded-lg flex items-center justify-center hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:bg-gray-600">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
                <p id="cooldown-timer" class="text-xs text-center text-red-400 h-4 mt-1"></p>
            </footer>
        </section>

    </main>

    <div id="loading-screen" class="flex justify-center items-center h-screen">
        <p id="loading-text" class="text-xl">Authenticating and loading messenger...</p>
    </div>

    <script type="module">
        // --- Firebase Core Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, getDocs, serverTimestamp, arrayUnion, arrayRemove, writeBatch, deleteField, deleteDoc, orderBy } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyASqfiYUPf7xY4wgZ0hLl8_Z0ZkBiwFUO8", // <<<<<<< CHANGE THIS TO YOUR REAL KEY
            authDomain: "theamericanmessenger-0.firebaseapp.com",
            databaseURL: "https://theamericanmessenger-0-default-rtdb.firebaseio.com",
            projectId: "theamericanmessenger-0",
            storageBucket: "theamericanmessenger-0.appspot.com",
            messagingSenderId: "963196851685",
            appId: "1:963196851685:web:9f709be8b2888ed4e28b0c",
            measurementId: "G-SBGEJDRSBZ"
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            document.getElementById('loading-text').innerHTML = `<p class="text-red-400 p-4 text-center">Firebase initialization failed. Check console for details.</p>`;
            throw e; 
        }

        // --- GLOBAL STATE & CONSTANTS ---
        let currentUser = null;
        let currentUserData = {};
        let currentChat = { id: null, type: null, name: null, partnerId: null, members: [] };
        let unsubscribeUser = () => {};
        let unsubscribeMessages = () => {};
        let unsubscribeChats = () => {};
        let chatCooldownInterval = null;
        let messageObserver = null;
        let localMessagesCache = JSON.parse(localStorage.getItem('4spLocalMessages')) || {};
        let attachedFiles = [];
        let currentTab = 'chats';
        
        const PUBLIC_ID_LENGTH = 8;
        const GC_MESSAGE_COOLDOWN_MS = 2000;
        const GC_MAX_USERS = 20;
        const CHAR_LIMIT_DM = 10000;
        const CHAR_LIMIT_GC = 5000;
        const MESSAGE_TRUNCATE_LENGTH = 1000; // New limit for text expansion
        const MAX_FILES_DM = 5;
        const MAX_FILES_GC = 3;
        const NICKNAME_STORAGE_KEY = 'messengerNicknames';
        const GROUP_NICKNAME_STORAGE_KEY = 'messengerGroupNicknames';
        
        // **DATABASE/CACHE CONSTANTS**
        const MESSAGE_CACHE_LIMIT_DM = 10; // saves last 10 messages to database
        const MESSAGE_CACHE_LIMIT_GC = 25; // saves last 25 for group chats
        // ------------------------------------

        const dom = {
            loadingScreen: document.getElementById('loading-screen'),
            loadingText: document.getElementById('loading-text'), 
            appUi: document.getElementById('app-ui'),
            leftPanel: document.getElementById('left-panel'),
            currentTimeDisplay: document.getElementById('current-time-display'),
            myIdDisplay: document.getElementById('my-id-display'), 
            chatsTabBtn: document.getElementById('chats-tab-btn'),
            friendsTabBtn: document.getElementById('friends-tab-btn'),
            addFriendSection: document.getElementById('add-friend-section'),
            groupChatControls: document.getElementById('group-chat-controls'),
            addFriendForm: document.getElementById('add-friend-form'),
            addFriendIdInput: document.getElementById('add-friend-id-input'),
            addFriendMessage: document.getElementById('add-friend-message'),
            friendRequestsSection: document.getElementById('friend-requests-section'),
            activeListItems: document.getElementById('active-list-items'), 
            chatView: document.getElementById('chat-view'),
            backToChatsBtn: document.getElementById('back-to-chats-btn'),
            chatHeader: document.getElementById('chat-header'),
            editLabelBtn: document.getElementById('edit-label-btn'),
            blockUserBtn: document.getElementById('block-user-btn'),
            editGroupNameBtn: document.getElementById('edit-group-name-btn'),
            manageGroupNicknamesBtn: document.getElementById('manage-group-nicknames-btn'),
            clearChatBtn: document.getElementById('clear-chat-btn'),
            messagesContainer: document.getElementById('messages-container'),
            messageForm: document.getElementById('message-form'),
            messageInput: document.getElementById('message-input'),
            sendBtn: document.getElementById('send-btn'),
            cooldownTimer: document.getElementById('cooldown-timer'),
            scrollToBottomBtn: document.getElementById('scroll-to-bottom-btn'), 
            // File Uploads
            openFileMenuBtn: document.getElementById('open-file-menu-btn'),
            fileMenu: document.getElementById('file-menu'),
            fileMenuImageBtn: document.getElementById('file-menu-image-btn'),
            fileMenuCameraBtn: document.getElementById('file-menu-camera-btn'),
            fileUploadInput: document.getElementById('file-upload-input'),
            cameraCaptureInput: document.getElementById('camera-capture-input'),
            filePreviewContainer: document.getElementById('file-preview-container'),
            charLimitDisplay: document.getElementById('char-limit-display'),
            // Modals
            createGroupModal: document.getElementById('create-group-modal'),
            createGroupBtn: document.getElementById('create-group-btn'),
            createGroupModalCloseBtn: document.getElementById('create-group-modal-close-btn'),
            createGroupForm: document.getElementById('create-group-form'),
            groupMembersList: document.getElementById('group-members-list'),
            groupNameInput: document.getElementById('group-name-input'),
            settingsModal: document.getElementById('settings-modal'),
            openSettingsBtn: document.getElementById('open-settings-btn'),
            settingsModalCloseBtn: document.getElementById('settings-modal-close-btn'),
            blockedUsersList: document.getElementById('blocked-users-list'),
            imageLightbox: document.getElementById('image-lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            confirmModal: {
                backdrop: document.getElementById('confirm-modal'),
                title: document.getElementById('confirm-modal-title'),
                body: document.getElementById('confirm-modal-body'),
                yesBtn: document.getElementById('confirm-modal-yes-btn'),
                noBtn: document.getElementById('confirm-modal-no-btn'),
            }
        };

        // =========================================================================
        // UTILITIES
        // =========================================================================
        
        function escapeHtml(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }
        
        function linkify(text) {
            const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
            return text.replace(urlRegex, (url, fullUrl, protocol, wwwUrl) => {
                const href = protocol ? fullUrl : `http://${wwwUrl}`;
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            });
        }

        function getFromStorage(key) { try { return JSON.parse(localStorage.getItem(key) || '{}'); } catch (e) { return {}; } }
        function saveToStorage(key, data) { localStorage.setItem(key, JSON.stringify(data)); }

        function setFriendNickname(uid, nickname) { const n = getFromStorage(NICKNAME_STORAGE_KEY); if (nickname) n[uid] = nickname; else delete n[uid]; saveToStorage(NICKNAME_STORAGE_KEY, n); }
        function getFriendNickname(uid, defaultLabel) { return getFromStorage(NICKNAME_STORAGE_KEY)[uid] || defaultLabel; }

        function setGroupNickname(groupId, memberId, nickname) { const allGroups = getFromStorage(GROUP_NICKNAME_STORAGE_KEY); if (!allGroups[groupId]) allGroups[groupId] = {}; if (nickname) allGroups[groupId][memberId] = nickname; else delete allGroups[groupId][memberId]; saveToStorage(GROUP_NICKNAME_STORAGE_KEY, allGroups); }
        function getGroupNickname(groupId, memberId) { const allGroups = getFromStorage(GROUP_NICKNAME_STORAGE_KEY); return allGroups[groupId]?.[memberId] || null; }
        
        function updateTime() { dom.currentTimeDisplay.textContent = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }); }
        
        function showMessage(element, text, type = 'info', duration = 3000) {
            element.textContent = text;
            element.className = `text-sm mt-2 min-h-[20px] ${type === 'error' ? 'text-red-400' : type === 'success' ? 'text-green-400' : 'text-gray-400'}`;
            setTimeout(() => { if (element.textContent === text) element.textContent = ''; }, duration);
        }

        // --- Modal & Lightbox Control ---
        function showModal(modalElement) { modalElement.classList.remove('hidden'); setTimeout(() => modalElement.classList.remove('opacity-0'), 10); }
        function hideModal(modalElement) { modalElement.classList.add('opacity-0'); setTimeout(() => modalElement.classList.add('hidden'), 300); }
        
        function showLightbox(src) { dom.lightboxImage.src = src; showModal(dom.imageLightbox); }
        
        function openGroupModal() { dom.groupNameInput.value = ''; renderGroupMemberSelection(); showModal(dom.createGroupModal); }
        function closeGroupModal() { hideModal(dom.createGroupModal); }
        function showSettingsModal() { renderBlockedUsers(); showModal(dom.settingsModal); }
        function closeSettingsModal() { hideModal(dom.settingsModal); }

        function showConfirmModal({ title, body, onConfirm }) {
            dom.confirmModal.title.textContent = title; dom.confirmModal.body.textContent = body;
            dom.confirmModal.yesBtn.onclick = () => { onConfirm(); hideModal(dom.confirmModal.backdrop); };
            dom.confirmModal.noBtn.onclick = () => hideModal(dom.confirmModal.backdrop);
            showModal(dom.confirmModal.backdrop);
        }

        function formatCharCount(num) {
            if (num < 1000) return num.toString();
            return (num / 1000).toFixed(1) + 'K';
        }

        function toggleFileMenu(e) {
            e.preventDefault();
            const rect = dom.openFileMenuBtn.getBoundingClientRect();
            // Calculate bottom position relative to viewport
            const menuTop = rect.top;
            const menuHeight = dom.fileMenu.offsetHeight || 150; // Estimate height if hidden
            let bottom = window.innerHeight - menuTop + 10;
            
            // Adjust if menu would go off-screen at the bottom
            if (menuTop - menuHeight < 0) {
                // If there's not enough room at the top, place it below (default bottom position is above)
                bottom = window.innerHeight - (rect.bottom + 10);
                dom.fileMenu.style.bottom = 'auto';
                dom.fileMenu.style.top = `${rect.bottom + 10}px`;
            } else {
                dom.fileMenu.style.top = 'auto';
                dom.fileMenu.style.bottom = `${bottom}px`;
            }

            dom.fileMenu.style.left = `${rect.left}px`;
            dom.fileMenu.classList.toggle('hidden');
        }
        
        // =========================================================================
        // ID, SCROLL, AND FILE HANDLING
        // =========================================================================

        async function generateUniqueId() {
            const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let publicId = '';
            let isUnique = false;
            let attempts = 0;

            while (!isUnique && attempts < 10) {
                publicId = '';
                for (let i = 0; i < PUBLIC_ID_LENGTH; i++) {
                    publicId += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                const q = query(collection(db, 'users'), where('publicId', '==', publicId));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    isUnique = true;
                }
                attempts++;
            }
            if (!isUnique) throw new Error("Failed to generate a unique ID after multiple attempts.");
            return publicId;
        }

        function getDmChatId(uid1, uid2) { return [uid1, uid2].sort().join('_'); }
        function isAtBottom() { return (dom.messagesContainer.scrollHeight - dom.messagesContainer.scrollTop - dom.messagesContainer.clientHeight) <= 5; }
        function scrollToBottom(smooth = false) { dom.messagesContainer.scrollTo({ top: dom.messagesContainer.scrollHeight, behavior: smooth ? 'smooth' : 'auto' }); dom.scrollToBottomBtn.classList.add('hidden'); }
        function updateScrollButtonVisibility() { dom.scrollToBottomBtn.classList.toggle('hidden', isAtBottom() || dom.messagesContainer.scrollHeight <= dom.messagesContainer.clientHeight); }

        function compressImage(imageFile) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const MAX_WIDTH = 800;
                        const scaleFactor = Math.min(1, MAX_WIDTH / img.width);
                        canvas.width = img.width * scaleFactor;
                        canvas.height = img.height * scaleFactor;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(imageFile);
            });
        }

        async function handleFileSelect(e) {
            dom.fileMenu.classList.add('hidden'); // Close menu
            const maxFiles = currentChat.type === 'group' ? MAX_FILES_GC : MAX_FILES_DM;
            const files = Array.from(e.target.files);
            for (const file of files) {
                if (attachedFiles.length >= maxFiles) { showMessage(dom.cooldownTimer, `Max ${maxFiles} images allowed.`, 'error'); break; }
                if (!file.type.startsWith('image/')) { showMessage(dom.cooldownTimer, 'Only image files are supported.', 'error'); continue; }
                
                if (attachedFiles.length >= 2) {
                    showMessage(dom.cooldownTimer, 'Max 2 images for reaction/single message attachment.', 'error');
                    break;
                }
                
                const dataUrl = await compressImage(file);
                attachedFiles.push({ name: file.name, type: 'image', dataURL: dataUrl });
            }
            e.target.value = ''; // Clear the input so selecting the same file works
            renderFilePreviews();
        }
        
        function removeFile(index) { attachedFiles.splice(index, 1); renderFilePreviews(); }
        function renderFilePreviews() {
            dom.filePreviewContainer.innerHTML = attachedFiles.map((file, index) => `
                <div class="file-preview" data-index="${index}">
                    <img src="${escapeHtml(file.dataURL)}" alt="Image Preview">
                    <button class="remove-file-btn" data-index="${index}"><i class="fas fa-times"></i></button>
                </div>`).join('');
            dom.filePreviewContainer.classList.toggle('hidden', attachedFiles.length === 0);
            dom.filePreviewContainer.querySelectorAll('.remove-file-btn').forEach(btn => btn.onclick = () => removeFile(parseInt(btn.dataset.index)));
        }

        // =========================================================================
        // MESSAGE & CHAT LOGIC
        // =========================================================================
        
        function saveMessagesToCache() { try { localStorage.setItem('4spLocalMessages', JSON.stringify(localMessagesCache)); } catch (e) { console.error("Error saving messages to cache:", e); } }
        
        function toggleMessageExpansion(messageWrapper) {
            const isExpanded = messageWrapper.classList.toggle('message-expanded');
            messageWrapper.classList.toggle('message-truncated', !isExpanded);
            const expandBtn = messageWrapper.querySelector('.expand-text-btn');
            if (expandBtn) {
                expandBtn.textContent = isExpanded ? 'Show Less' : '...Show More';
            }
        }

        function renderMessage(message) {
            if (message.senderId === 'system' || message.deleted) {
                if (message.senderId === 'system') {
                    const timeString = message.timestamp?.toDate ? new Date(message.timestamp.toDate()).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '...';
                    const systemEl = document.createElement('div');
                    systemEl.className = 'text-center text-xs text-gray-500 my-2';
                    systemEl.innerHTML = `<span>${escapeHtml(message.text)} (${timeString})</span>`;
                    return systemEl;
                }
                return null;
            }

            const isMe = message.senderId === currentUser.uid;
            let senderName;
            
            if (isMe) {
                senderName = 'You';
            } else if (currentChat.type === 'group') {
                senderName = getGroupNickname(currentChat.id, message.senderId) || getFriendNickname(message.senderId, currentUserData.friends[message.senderId] || 'Unknown');
            } else {
                senderName = getFriendNickname(message.senderId, currentUserData.friends[message.senderId] || 'Unknown');
            }
            
            const timeString = message.timestamp?.toDate ? new Date(message.timestamp.toDate()).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : (message.isoTimestamp ? new Date(message.isoTimestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '...');
            const isRead = currentChat.type === 'dm' && message.readBy?.includes(currentChat.partnerId);
            const isStillInDatabase = !message.isoTimestamp; // Simplistic check: if it has a server timestamp, it's still in the DB. Local cache will have isoTimestamp.
            const canEditOrDelete = isMe && isStillInDatabase && message.text; 

            // Reaction Images (Placeholder for 2 images)
            const filesHtml = (message.files || []).slice(0, 2).map(f => `
                <div class="p-1 bg-gray-900 rounded-lg max-w-full overflow-hidden mb-2 ${message.files.length > 1 ? 'w-48 inline-block mr-2' : ''}">
                    <img src="${escapeHtml(f.dataURL)}" class="max-h-60 object-contain rounded-md cursor-pointer" onclick="showLightbox('${escapeHtml(f.dataURL)}')">
                </div>`).join('');
            
            let messageText = message.text || '';
            const isTruncated = messageText.length > MESSAGE_TRUNCATE_LENGTH;
            // The full text is kept in the element to let CSS handle initial truncation
            
            const contentHtml = message.text ? `
                <div class="message-content whitespace-pre-wrap">
                    ${linkify(escapeHtml(messageText))}
                </div>
                ${isTruncated ? `<button class="expand-text-btn text-xs text-indigo-300 hover:text-indigo-200 mt-1" data-action="toggle-expand">...Show More</button>` : ''}
                ` : '';
            
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper flex items-end gap-2 ${isMe ? 'justify-end' : 'justify-start'} ${isMe ? 'ml-auto' : 'mr-auto'} ${isTruncated ? 'message-truncated' : ''}`;
            wrapper.dataset.messageId = message.id;
            wrapper.dataset.senderId = message.senderId;
            if (!isMe && !message.readBy?.includes(currentUser.uid)) {
                wrapper.dataset.isUnread = "true";
            }
            
            // Simplified Reactions/Context Menu
            const optionsMenu = `
                <div class="message-options flex gap-1 ${isMe ? 'order-first' : 'order-last'}">
                    <button class="w-6 h-6 bg-gray-900/70 text-gray-400 rounded-full hover:bg-gray-700 transition text-xs" title="React with Thumbs Up"><i class="far fa-thumbs-up"></i></button>
                    <button class="w-6 h-6 bg-gray-900/70 text-gray-400 rounded-full hover:bg-gray-700 transition text-xs" title="React with Heart"><i class="far fa-heart"></i></button>
                    ${canEditOrDelete ? `
                        <button class="delete-message-btn w-6 h-6 bg-gray-900/70 text-red-400 rounded-full hover:bg-red-700 hover:text-white transition text-xs" data-id="${message.id}" title="Delete Message"><i class="fas fa-trash-alt"></i></button>
                        <button class="edit-message-btn w-6 h-6 bg-gray-900/70 text-indigo-400 rounded-full hover:bg-indigo-700 hover:text-white transition text-xs" data-id="${message.id}" data-text="${escapeHtml(message.text)}" title="Edit Message"><i class="fas fa-edit"></i></button>
                    ` : ''}
                </div>
            `;


            const readIndicatorHtml = isMe ? `<div class="message-read-indicator text-xs self-end mb-1 mr-1 ${isRead ? 'visible' : ''}">
                ${isRead ? '<i class="fas fa-eye" title="Read"></i>' : '<i class="fas fa-eye-slash" title="Delivered"></i>'}
            </div>` : '';
            
            wrapper.innerHTML = `
                ${!isMe ? readIndicatorHtml : ''}
                ${isMe ? optionsMenu : ''}
                <div class="flex flex-col ${isMe ? 'items-end' : 'items-start'}">
                    <span class="text-xs ${isMe ? 'text-gray-500' : 'text-indigo-400'} mb-1 font-semibold">${escapeHtml(senderName)}</span>
                    <div class="p-3 rounded-xl ${isMe ? 'bg-indigo-600 text-white rounded-tr-none' : 'bg-gray-800 text-gray-200 rounded-tl-none'} shadow-lg break-words max-w-full relative">
                        ${filesHtml}
                        ${contentHtml}
                        ${message.edited ? `<p class="text-[10px] text-gray-400 mt-1">${isMe ? 'Edited' : `${senderName} edited`}</p>` : ''}
                    </div>
                    <span class="text-xs text-gray-600 mt-1">${timeString}</span>
                </div>
                ${!isMe ? optionsMenu : ''}
                ${isMe ? readIndicatorHtml : ''}
            `;
            
            // Add listeners for new functionality
            if (isTruncated) {
                wrapper.querySelector('[data-action="toggle-expand"]').addEventListener('click', () => toggleMessageExpansion(wrapper));
            }

            // Context menu listeners
            const deleteBtn = wrapper.querySelector('.delete-message-btn');
            if (deleteBtn) deleteBtn.onclick = () => handleDeleteMessage(deleteBtn.dataset.id);
            const editBtn = wrapper.querySelector('.edit-message-btn');
            if (editBtn) editBtn.onclick = () => handleEditMessage(editBtn.dataset.id, editBtn.dataset.text);

            return wrapper;
        }
        
        async function handleDeleteMessage(messageId) {
            showConfirmModal({ title: 'Delete Message?', body: 'This message will be permanently deleted for all users. This cannot be undone.', onConfirm: async () => {
                try {
                    const messageRef = doc(db, 'chats', currentChat.id, 'messages', messageId);
                    // Use update to mark as deleted instead of deleteDoc (safer, cleaner for chat history)
                    await updateDoc(messageRef, { text: '[This message was deleted]', deleted: true, files: [] }); 
                    showMessage(dom.cooldownTimer, 'Message deleted.', 'success');
                } catch (error) {
                    console.error("Error deleting message:", error);
                    showMessage(dom.cooldownTimer, 'Failed to delete message. (Only messages still in DB can be deleted)', 'error');
                }
            }});
        }

        async function handleEditMessage(messageId, oldText) {
            const newText = prompt('Edit your message:', oldText);
            if (newText === null || newText.trim() === oldText.trim() || newText.trim().length === 0) return;

            try {
                const messageRef = doc(db, 'chats', currentChat.id, 'messages', messageId);
                await updateDoc(messageRef, { text: newText.trim(), edited: serverTimestamp() });
                showMessage(dom.cooldownTimer, 'Message edited.', 'success');
            } catch (error) {
                console.error("Error editing message:", error);
                showMessage(dom.cooldownTimer, 'Failed to edit message. (Only messages still in DB can be edited)', 'error');
            }
        }
        
        async function handleClearChat() {
            showConfirmModal({ title: 'Clear Chat History?', body: 'This will only clear messages locally (from your device). The messages will remain on the server and other devices.', onConfirm: () => {
                delete localMessagesCache[currentChat.id];
                saveMessagesToCache();
                // Re-render the chat view to show it's empty
                listenToMessages(currentChat.id); 
                showMessage(dom.cooldownTimer, 'Local chat history cleared.', 'success');
            }});
        }

        async function markMessageAsRead(messageId) {
            if (!currentChat.id || currentChat.type !== 'dm' || !currentChat.partnerId) return;
            const messageRef = doc(db, 'chats', currentChat.id, 'messages', messageId);
            await updateDoc(messageRef, { readBy: arrayUnion(currentUser.uid) }).catch(console.error);
        }

        function setupMessageObserver() {
            if (messageObserver) messageObserver.disconnect();
            
            const options = { root: dom.messagesContainer, threshold: 0.8 };
            
            messageObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const el = entry.target;
                    const timeoutId = parseInt(el.dataset.readTimeoutId);

                    if (entry.isIntersecting) {
                        if (!timeoutId && el.dataset.isUnread === "true") {
                           const newTimeoutId = setTimeout(() => {
                                markMessageAsRead(el.dataset.messageId);
                                delete el.dataset.isUnread; 
                                delete el.dataset.readTimeoutId;
                           }, 1000);
                           el.dataset.readTimeoutId = newTimeoutId;
                        }
                    } else {
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                            delete el.dataset.readTimeoutId;
                        }
                    }
                });
            }, options);
        }

        function listenToMessages(chatId) {
            unsubscribeMessages();
            setupMessageObserver();
            dom.messagesContainer.innerHTML = '';
            
            const cached = localMessagesCache[chatId] || [];
            if (cached.length > 0) {
                cached.forEach(msg => {
                    const msgEl = renderMessage({ ...msg, timestamp: { toDate: () => new Date(msg.isoTimestamp) } });
                    if (msgEl) dom.messagesContainer.appendChild(msgEl);
                });
                scrollToBottom();
            } else {
                dom.messagesContainer.innerHTML = `<div id="messages-loading-state" class="flex justify-center items-center h-full"><p class="text-gray-500">Loading messages...</p></div>`;
            }

            const messagesRef = collection(db, 'chats', chatId, 'messages');
            const q = query(messagesRef, orderBy('timestamp', 'asc'));

            unsubscribeMessages = onSnapshot(q, (snapshot) => {
                const shouldScroll = isAtBottom() || !!dom.messagesContainer.querySelector('#messages-loading-state');
                
                const existingMessageIds = new Set(Array.from(dom.messagesContainer.children).map(el => el.dataset.messageId).filter(id => id));
                const messagesToCache = [];
                let hasNewMessage = false;

                snapshot.docChanges().forEach(change => {
                    const data = { ...change.doc.data(), id: change.doc.id };

                    if (data.timestamp) {
                        messagesToCache.push({ ...data, isoTimestamp: data.timestamp.toDate().toISOString() });
                    }
                    
                    const existingEl = dom.messagesContainer.querySelector(`[data-message-id="${data.id}"]`) || dom.messagesContainer.querySelector(`div.text-center > span:contains('${data.text}')`); // Find system messages too
                    
                    if (change.type === "added" && !existingMessageIds.has(data.id)) {
                         hasNewMessage = true;
                         const messageElement = renderMessage(data);
                         if (messageElement) {
                             dom.messagesContainer.appendChild(messageElement);
                             if (messageElement.dataset.isUnread) { messageObserver.observe(messageElement); }
                         }
                    } else if (change.type === "modified" && existingEl) {
                        const newMessageElement = renderMessage(data);
                        if (newMessageElement) {
                            dom.messagesContainer.replaceChild(newMessageElement, existingEl);
                            if (newMessageElement.dataset.isUnread) { messageObserver.observe(newMessageElement); }
                        } else {
                            existingEl.remove(); 
                        }
                    } else if (change.type === "removed" && existingEl) {
                        existingEl.remove();
                    }
                });
                
                // Remove loading state if it exists
                const loadingState = dom.messagesContainer.querySelector('#messages-loading-state');
                if (loadingState) loadingState.remove();

                // If container is empty after processing, show default text
                if (dom.messagesContainer.children.length === 0) {
                     dom.messagesContainer.innerHTML = `<div class="flex justify-center items-center h-full"><p class="text-gray-500">Say something!</p></div>`;
                }

                // Save last X messages (user-defined cache limits)
                const cacheLimit = currentChat.type === 'group' ? MESSAGE_CACHE_LIMIT_GC : MESSAGE_CACHE_LIMIT_DM;
                localMessagesCache[chatId] = messagesToCache.slice(-cacheLimit);
                saveMessagesToCache();

                if (shouldScroll || hasNewMessage) scrollToBottom(true);
                else updateScrollButtonVisibility();
                
            }, (error) => {
                console.error("Error listening to messages:", error);
                dom.messagesContainer.innerHTML = `<p class="text-red-400 text-center">Failed to load messages.</p>`;
            });
        }

        async function handleMessageSubmit(e) {
            if (e) e.preventDefault();
            if (!currentUser || !currentChat.id || dom.sendBtn.disabled) return;
            
            let messageText = dom.messageInput.value.trim();
            if (!messageText && attachedFiles.length === 0) return;
            
            const isGroup = currentChat.type === 'group';

            if (isGroup) dom.sendBtn.disabled = true;

            try {
                const batch = writeBatch(db);
                const chatRef = doc(db, 'chats', currentChat.id);
                const newMessageRef = doc(collection(chatRef, 'messages'));

                const message = {
                    senderId: currentUser.uid, text: messageText, timestamp: serverTimestamp(),
                    files: attachedFiles, readBy: [currentUser.uid], deleted: false
                };
                batch.set(newMessageRef, message);
                
                const preview = messageText.substring(0, 50) || (attachedFiles.length > 0 ? `[${attachedFiles.length} images]` : '');
                batch.update(chatRef, { lastMessage: { text: preview, timestamp: serverTimestamp(), sender: currentUser.uid } });
                
                await batch.commit();

                dom.messageInput.value = '';
                attachedFiles = [];
                renderFilePreviews();
                updateCharacterLimitDisplay();
                dom.messageInput.focus();

                if (isGroup) {
                    let remaining = GC_MESSAGE_COOLDOWN_MS / 1000;
                    dom.cooldownTimer.textContent = `Wait ${remaining}s`;
                    chatCooldownInterval = setInterval(() => {
                        remaining--;
                        if (remaining <= 0) {
                            clearInterval(chatCooldownInterval);
                            dom.cooldownTimer.textContent = '';
                            dom.sendBtn.disabled = false;
                        } else { dom.cooldownTimer.textContent = `Wait ${remaining}s`; }
                    }, 1000);
                }
            } catch (error) {
                console.error("Error sending message:", error);
                showMessage(dom.cooldownTimer, 'Failed to send.', 'error');
                if (isGroup) dom.sendBtn.disabled = false;
            }
        }
        
        // =========================================================================
        // FRIEND, BLOCK, GROUP, and CHAT MANAGEMENT
        // =========================================================================

        async function handleAddFriend(e) {
            if (e) e.preventDefault();
            const publicId = dom.addFriendIdInput.value.trim().toLowerCase();
            dom.addFriendIdInput.value = '';
            if (publicId === currentUserData.publicId) { showMessage(dom.addFriendMessage, 'Cannot add yourself.', 'error'); return; }
            if (currentUserData.friends && Object.values(currentUserData.friends).includes(publicId)) { showMessage(dom.addFriendMessage, 'You are already friends.', 'error'); return; }

            try {
                const q = query(collection(db, 'users'), where('publicId', '==', publicId));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) { showMessage(dom.addFriendMessage, 'User not found.', 'error'); return; }

                const friendDoc = querySnapshot.docs[0];
                const friendUid = friendDoc.id;

                if (currentUserData.blocked.includes(friendUid)) { showMessage(dom.addFriendMessage, 'Unblock user first.', 'error'); return; }
                
                // Fetch friend's data to check if I am blocked
                const friendData = friendDoc.data();
                if (friendData.blocked?.includes(currentUser.uid)) { showMessage(dom.addFriendMessage, 'You are blocked by this user.', 'error'); return; }
                
                // Check if a request is already pending from either side
                if ((currentUserData.pending_requests || []).includes(friendUid)) { showMessage(dom.addFriendMessage, 'Friend request from this user is pending. Accept it!', 'info'); return; }
                if ((friendData.pending_requests || []).includes(currentUser.uid)) { showMessage(dom.addFriendMessage, 'Friend request already sent.', 'info'); return; }
                
                // Send request (add current user's UID to friend's pending_requests)
                await updateDoc(doc(db, 'users', friendUid), { pending_requests: arrayUnion(currentUser.uid) });
                showMessage(dom.addFriendMessage, 'Friend request sent.', 'success');

            } catch (error) {
                console.error("Error adding friend:", error);
                showMessage(dom.addFriendMessage, 'Error sending request.', 'error');
            }
        }

        function renderFriendRequests(requests) {
            if (!requests || requests.length === 0) {
                dom.friendRequestsSection.innerHTML = '';
                return;
            }

            const requestPromises = requests.map(reqUid => getDoc(doc(db, 'users', reqUid)));
            Promise.all(requestPromises).then(snapshots => {
                const requestUsers = snapshots.filter(d => d.exists()).map(doc => ({ uid: doc.id, publicId: doc.data().publicId }));
                
                const html = `
                    <h3 class="text-lg font-bold text-yellow-400 mb-2">Friend Requests (${requestUsers.length})</h3>
                    ${requestUsers.map(user => `
                        <div class="flex items-center justify-between p-3 bg-gray-900 rounded-lg mb-2">
                            <span class="font-mono">${escapeHtml(user.publicId)}</span>
                            <div class="flex gap-2">
                                <button class="text-green-400 hover:text-green-500 transition" data-action="accept" data-uid="${user.uid}" data-id="${user.publicId}" title="Accept"><i class="fas fa-check"></i></button>
                                <button class="text-red-400 hover:text-red-500 transition" data-action="decline" data-uid="${user.uid}" data-id="${user.publicId}" title="Decline"><i class="fas fa-times"></i></button>
                            </div>
                        </div>
                    `).join('')}
                `;
                dom.friendRequestsSection.innerHTML = html;
            }).catch(e => {
                console.error("Error rendering requests:", e);
                dom.friendRequestsSection.innerHTML = '<p class="text-red-400">Failed to load requests.</p>';
            });
        }

        async function handleFriendRequestAction(e) {
            const btn = e.target.closest('[data-action]');
            if (!btn) return;

            const action = btn.dataset.action;
            const friendUid = btn.dataset.uid;
            const friendPublicId = btn.dataset.id;
            
            try {
                const batch = writeBatch(db);
                const myRef = doc(db, 'users', currentUser.uid);
                const friendRef = doc(db, 'users', friendUid);

                // 1. Remove request from my pending list
                batch.update(myRef, { pending_requests: arrayRemove(friendUid) });

                if (action === 'accept') {
                    const chatId = getDmChatId(currentUser.uid, friendUid);
                    const chatRef = doc(db, 'chats', chatId);

                    // 2. Add as friend to both users' friend lists
                    batch.update(myRef, { [`friends.${friendUid}`]: friendPublicId });
                    batch.update(friendRef, { [`friends.${currentUser.uid}`]: currentUserData.publicId });

                    // 3. Create/Ensure chat document exists
                    batch.set(chatRef, { 
                        type: 'dm',
                        members: [currentUser.uid, friendUid],
                        createdAt: serverTimestamp(),
                        lastMessage: { text: `Chat started with ${currentUserData.publicId}`, timestamp: serverTimestamp(), sender: 'system' }
                    }, { merge: true });

                    await batch.commit();
                    showMessage(dom.addFriendMessage, `Accepted request from ${friendPublicId}.`, 'success');
                } else if (action === 'decline') {
                    await batch.commit();
                    showMessage(dom.addFriendMessage, `Declined request from ${friendPublicId}.`, 'info');
                }

            } catch (error) {
                console.error(`Error ${action}ing friend request:`, error);
                showMessage(dom.addFriendMessage, 'Error processing request.', 'error');
            }
        }

        async function handleUnfriend(friendUid, friendName) {
            try {
                const batch = writeBatch(db);
                const myRef = doc(db, 'users', currentUser.uid);
                const friendRef = doc(db, 'users', friendUid);
                
                // 1. Remove from my friends list
                batch.update(myRef, { [`friends.${friendUid}`]: deleteField() });
                
                // 2. Remove from friend's friends list
                batch.update(friendRef, { [`friends.${currentUser.uid}`]: deleteField() });
                
                // 3. Delete the DM chat document
                const chatId = getDmChatId(currentUser.uid, friendUid);
                batch.delete(doc(db, 'chats', chatId));

                await batch.commit();
                setFriendNickname(friendUid, ''); // Clear local nickname
                showMessage(dom.cooldownTimer, `Unfriended ${friendName}.`, 'success');
                if (currentChat.id === chatId) closeChat();
                switchTab('friends');

            } catch (error) {
                console.error("Error unfriending:", error);
                showMessage(dom.cooldownTimer, 'Failed to unfriend.', 'error');
            }
        }

        async function handleBlockUser(friendUid, friendName) {
            showConfirmModal({ 
                title: `Block ${friendName}?`, 
                body: 'This will remove them as a friend, delete your DM chat, and prevent future contact.', 
                onConfirm: async () => {
                    try {
                        const batch = writeBatch(db);
                        const myRef = doc(db, 'users', currentUser.uid);
                        
                        // 1. Add to my blocked list
                        batch.update(myRef, { blocked: arrayUnion(friendUid) });
                        
                        // 2. If they are a friend, remove them
                        if (currentUserData.friends?.[friendUid]) {
                            batch.update(myRef, { [`friends.${friendUid}`]: deleteField() });
                            
                            // 3. Remove me from their friend list
                            const friendRef = doc(db, 'users', friendUid);
                            batch.update(friendRef, { [`friends.${currentUser.uid}`]: deleteField() });
                            
                            // 4. Delete the DM chat
                            const chatId = getDmChatId(currentUser.uid, friendUid);
                            batch.delete(doc(db, 'chats', chatId));
                        }

                        // Remove any pending request from them
                         batch.update(myRef, { pending_requests: arrayRemove(friendUid) });


                        await batch.commit();
                        setFriendNickname(friendUid, ''); // Clear local nickname
                        showMessage(dom.cooldownTimer, `Blocked ${friendName}.`, 'success');
                        if (currentChat.partnerId === friendUid) closeChat();
                        switchTab('friends');
                        
                    } catch (error) {
                        console.error("Error blocking user:", error);
                        showMessage(dom.cooldownTimer, 'Failed to block user.', 'error');
                    }
                }
            });
        }

        async function handleUnblockUser(blockedUid, blockedName) {
            try {
                await updateDoc(doc(db, 'users', currentUser.uid), { blocked: arrayRemove(blockedUid) });
                showMessage(dom.cooldownTimer, `Unblocked ${blockedName}.`, 'success');
                showSettingsModal(); // Refresh the list
            } catch (error) {
                console.error("Error unblocking user:", error);
                showMessage(dom.cooldownTimer, 'Failed to unblock user.', 'error');
            }
        }

        function renderBlockedUsers() {
            const blockedUids = currentUserData.blocked || [];
            if (blockedUids.length === 0) {
                dom.blockedUsersList.innerHTML = '<p class="text-gray-500 text-sm p-2 text-center">No users are blocked.</p>';
                return;
            }
            
            // Fetch public IDs of blocked users
            const userPromises = blockedUids.map(uid => getDoc(doc(db, 'users', uid)).then(doc => ({ uid, publicId: doc.exists() ? doc.data().publicId : 'Unknown' })));
            
            Promise.all(userPromises).then(blockedUsers => {
                dom.blockedUsersList.innerHTML = blockedUsers.map(user => `
                    <div class="flex items-center justify-between p-2 bg-gray-900 rounded-lg">
                        <span class="font-mono text-gray-400">${escapeHtml(user.publicId)}</span>
                        <button class="text-indigo-400 hover:text-indigo-500 transition text-sm font-semibold" data-action="unblock" data-uid="${user.uid}" data-name="${user.publicId}">Unblock</button>
                    </div>
                `).join('');
                
                dom.blockedUsersList.querySelectorAll('[data-action="unblock"]').forEach(btn => {
                    btn.onclick = () => handleUnblockUser(btn.dataset.uid, btn.dataset.name);
                });
            }).catch(e => {
                console.error("Error rendering blocked users:", e);
                dom.blockedUsersList.innerHTML = '<p class="text-red-400 p-2">Failed to load blocked users.</p>';
            });
        }

        async function handleDeleteChat(chatId, isGroup) {
            showConfirmModal({
                title: isGroup ? 'Leave and Delete Group?' : 'Delete DM Chat?',
                body: isGroup ? 'You will leave this group. The chat history will be deleted for everyone, but the group remains for the other members.' : 'This will permanently delete the DM chat history for both users.',
                onConfirm: async () => {
                    try {
                        if (isGroup) {
                            // Group: Remove user from members list
                            await updateDoc(doc(db, 'chats', chatId), { members: arrayRemove(currentUser.uid) });
                            // Send a system message indicating the user left
                            const chatRef = doc(db, 'chats', chatId);
                             const newMessageRef = doc(collection(chatRef, 'messages'));
                             await setDoc(newMessageRef, {
                                senderId: 'system', text: `${currentUserData.publicId} left the group.`, timestamp: serverTimestamp()
                             });
                        } else {
                            // DM: Delete the entire chat document
                            await deleteDoc(doc(db, 'chats', chatId));
                        }

                        delete localMessagesCache[chatId];
                        saveMessagesToCache();
                        
                        showMessage(dom.cooldownTimer, `${isGroup ? 'Left group' : 'Chat deleted'}.`, 'success');
                        if (currentChat.id === chatId) closeChat();
                        switchTab('chats');
                    } catch (error) {
                        console.error("Error deleting chat:", error);
                        showMessage(dom.cooldownTimer, 'Failed to delete/leave chat.', 'error');
                    }
                }
            });
        }

        async function renderGroupMemberSelection() {
            dom.groupMembersList.innerHTML = '';
            const friendUids = Object.keys(currentUserData.friends || {});
            
            if (friendUids.length === 0) {
                dom.groupMembersList.innerHTML = '<p class="text-gray-500 text-center p-4">You must have friends to create a group chat.</p>';
                return;
            }
            
            const friendPromises = friendUids.map(uid => getDoc(doc(db, 'users', uid)));
            
            Promise.all(friendPromises).then(snapshots => {
                const friends = snapshots.filter(d => d.exists() && !currentUserData.blocked.includes(d.id)).map(d => ({ 
                    uid: d.id, 
                    publicId: d.data().publicId, 
                    label: getFriendNickname(d.id, d.data().publicId) 
                }));
                
                dom.groupMembersList.innerHTML = `
                    ${friends.map(friend => `
                        <div class="flex items-center justify-between compact-list-item cursor-default">
                            <label for="member-${friend.uid}" class="flex items-center flex-grow cursor-pointer">
                                <input type="checkbox" id="member-${friend.uid}" name="member" value="${friend.uid}" class="w-4 h-4 text-indigo-600 bg-gray-900 border-gray-700 rounded focus:ring-indigo-500 mr-3">
                                <span class="text-gray-300">${escapeHtml(friend.label)}</span>
                                <span class="text-gray-500 text-xs ml-2 font-mono">(${escapeHtml(friend.publicId)})</span>
                            </label>
                        </div>
                    `).join('')}
                `;
            });
        }

        async function handleCreateGroup(e) {
            if (e) e.preventDefault();
            
            const groupName = dom.groupNameInput.value.trim();
            const selectedMembers = Array.from(dom.groupMembersList.querySelectorAll('input[name="member"]:checked')).map(input => input.value);
            
            if (!groupName) { showMessage(dom.cooldownTimer, 'Group name is required.', 'error', 5000); return; }
            if (selectedMembers.length === 0) { showMessage(dom.cooldownTimer, 'Select at least one member.', 'error', 5000); return; }
            
            const allMembers = [currentUser.uid, ...selectedMembers];
            if (allMembers.length > GC_MAX_USERS) { showMessage(dom.cooldownTimer, `Group limit is ${GC_MAX_USERS} users.`, 'error', 5000); return; }

            try {
                const newChatRef = doc(collection(db, 'chats'));
                
                await setDoc(newChatRef, {
                    type: 'group',
                    name: groupName,
                    owner: currentUser.uid,
                    members: allMembers,
                    createdAt: serverTimestamp(),
                    lastMessage: { text: `Group "${groupName}" created by ${currentUserData.publicId}`, timestamp: serverTimestamp(), sender: 'system' }
                });

                closeGroupModal();
                showMessage(dom.cooldownTimer, `Group "${groupName}" created!`, 'success', 5000);
                switchTab('chats');
                // Automatically open the new chat
                setTimeout(() => openChat(newChatRef.id, 'group', groupName, null, allMembers), 500);

            } catch (error) {
                console.error("Error creating group:", error);
                showMessage(dom.cooldownTimer, 'Failed to create group.', 'error', 5000);
            }
        }

        async function handleEditGroupName() {
            if (currentChat.type !== 'group') return;
            const newName = prompt(`Enter new name for "${currentChat.name}":`, currentChat.name);
            if (newName && newName.trim() !== currentChat.name && newName.trim().length > 0) {
                try {
                    const chatRef = doc(db, 'chats', currentChat.id);
                    await updateDoc(chatRef, { name: newName.trim() });
                    dom.chatHeader.textContent = newName.trim();
                    // Send system message about the change
                    const newMessageRef = doc(collection(chatRef, 'messages'));
                    await setDoc(newMessageRef, {
                        senderId: 'system', text: `${currentUserData.publicId} changed the group name to "${newName.trim()}"`, timestamp: serverTimestamp()
                    });
                    showMessage(dom.cooldownTimer, 'Group name updated.', 'success');
                } catch (error) {
                    console.error("Error updating group name:", error);
                    showMessage(dom.cooldownTimer, 'Failed to update group name.', 'error');
                }
            }
        }

        async function handleManageGroupNicknames() {
            if (currentChat.type !== 'group') return;

            // Fetch friend data for all group members
            const memberUids = currentChat.members;
            const memberPromises = memberUids.map(uid => getDoc(doc(db, 'users', uid)));
            const snapshots = await Promise.all(memberPromises);
            
            const membersData = snapshots.map(d => ({
                uid: d.id,
                publicId: d.data()?.publicId || 'Unknown',
                currentNickname: getGroupNickname(currentChat.id, d.id) || getFriendNickname(d.id, d.data()?.publicId || 'Unknown')
            }));
            
            const html = `
                <h3 class="text-xl font-bold mb-4 text-white">Manage Nicknames for ${escapeHtml(currentChat.name)}</h3>
                <p class="text-sm text-gray-500 mb-4">Set a local nickname for each group member. Only you will see these.</p>
                <form id="group-nickname-form" class="flex flex-col gap-4">
                    ${membersData.map(member => `
                        <div class="flex flex-col">
                            <label class="text-gray-300 font-semibold mb-1">${escapeHtml(member.publicId)}${member.uid === currentUser.uid ? ' (You)' : ''}</label>
                            <input type="text" name="${member.uid}" placeholder="Nickname (e.g., ${escapeHtml(member.currentNickname)})" value="${getGroupNickname(currentChat.id, member.uid) || ''}" maxlength="50" class="bg-gray-900 border-gray-700 rounded-lg p-2">
                        </div>
                    `).join('')}
                    <button type="submit" class="px-4 py-2 bg-indigo-600 rounded-lg hover:bg-indigo-700 transition font-semibold w-full mt-4">Save Nicknames</button>
                </form>
                <button id="group-nickname-modal-close-btn" class="mt-3 text-sm text-gray-400 hover:text-white w-full">Cancel</button>
            `;
            
            const modal = document.createElement('div');
            modal.className = 'modal-backdrop opacity-0';
            modal.innerHTML = `<div class="modal-content max-w-sm">${html}</div>`;
            document.body.appendChild(modal);
            showModal(modal);

            modal.querySelector('#group-nickname-modal-close-btn').onclick = () => hideModal(modal);
            
            modal.querySelector('#group-nickname-form').onsubmit = (e) => {
                e.preventDefault();
                const formData = new FormData(e.target);
                
                membersData.forEach(member => {
                    const newNickname = formData.get(member.uid).trim();
                    setGroupNickname(currentChat.id, member.uid, newNickname);
                });
                
                hideModal(modal);
                // Re-render chat list to reflect changes
                if (currentChat.type === 'group') {
                     // Since chat list depends on friend nicknames, refresh the view
                     switchTab('chats');
                     // Messages re-render on next message update
                }
                showMessage(dom.cooldownTimer, 'Group nicknames saved locally.', 'success');
            };
        }

        function renderChatItemHtml(chatDoc, chatName, iconClass, partnerId, members) {
            const isDM = chatDoc.type === 'dm';
            const lastMessage = chatDoc.lastMessage || { text: 'Start a conversation!', sender: 'system' };
            let previewText = lastMessage.text || '';
            if (previewText.length > 30) previewText = previewText.substring(0, 30) + '...';
            
            const lastSenderName = lastMessage.sender === 'system' ? 'System' : 
                                 (lastMessage.sender === currentUser.uid ? 'You' : 
                                 (isDM ? getFriendNickname(partnerId, currentUserData.friends[partnerId] || 'Unknown') : 
                                 getGroupNickname(chatDoc.id, lastMessage.sender) || currentUserData.friends[lastMessage.sender] || 'Member'));

            const timeString = lastMessage.timestamp?.toDate ? new Date(lastMessage.timestamp.toDate()).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '...';

            const membersString = (members || []).join(',');
            
            return `
                <div class="compact-list-item flex items-start justify-between group ${chatDoc.id === currentChat.id ? 'active' : ''}" data-list-chat-id="${chatDoc.id}">
                    <div class="flex items-center flex-grow min-w-0" data-action="open-chat" data-chat-id="${chatDoc.id}" data-chat-type="${chatDoc.type}" data-chat-name="${escapeHtml(chatName)}" data-partner-id="${partnerId || ''}" data-members="${membersString}">
                        <i class="${iconClass} text-indigo-400 mr-4 text-xl flex-shrink-0"></i>
                        <div class="flex flex-col min-w-0 flex-grow">
                            <div class="flex justify-between items-center mb-0.5">
                                <span class="font-semibold text-white truncate">${escapeHtml(chatName)}</span>
                                <span class="text-xs text-gray-500 flex-shrink-0 ml-2">${timeString}</span>
                            </div>
                            <p class="text-sm text-gray-400 truncate">
                                ${lastMessage.sender !== 'system' && !isDM ? `<span class="font-semibold text-gray-300 mr-1">${escapeHtml(lastSenderName)}:</span>` : ''}
                                ${escapeHtml(previewText)}
                            </p>
                        </div>
                    </div>
                    <div class="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity ml-4">
                        <button class="text-gray-500 hover:text-red-500 transition delete-chat-btn" data-id="${chatDoc.id}" data-is-group="${!isDM}" title="${isDM ? 'Delete Chat' : 'Leave Group'}">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                </div>
            `;
        }

        function listenToChats(uid) {
            unsubscribeChats();
            dom.activeListItems.innerHTML = '<p class="p-4 text-center text-gray-500">Loading chats...</p>';

            const chatsRef = collection(db, 'chats');
            const q = query(chatsRef, where('members', 'array-contains', uid));

            // This is the main onSnapshot listener for the chat list
            unsubscribeChats = onSnapshot(q, (snapshot) => {
                const chatDocs = [];
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    // Filter out DMs where the partner is blocked by the current user
                    if (data.type === 'dm') {
                        const partnerId = data.members.find(member => member !== uid);
                        if (currentUserData.blocked.includes(partnerId)) return;
                    }
                    // Filter out groups where user is no longer a member (safety check)
                    if (data.type === 'group' && !data.members.includes(uid)) return;

                    chatDocs.push({ ...data, id: doc.id });
                });
                
                // Sort by last message timestamp (descending)
                chatDocs.sort((a, b) => {
                    const timeA = a.lastMessage?.timestamp?.toDate()?.getTime() || 0;
                    const timeB = b.lastMessage?.timestamp?.toDate()?.getTime() || 0;
                    return timeB - timeA;
                });

                if (chatDocs.length === 0) {
                    dom.activeListItems.innerHTML = '<p class="p-4 text-center text-gray-500">You have no active chats. Add a friend or create a group!</p>';
                    return;
                }

                const html = chatDocs.map(chatDoc => {
                    const isDM = chatDoc.type === 'dm';
                    let chatName, iconClass, partnerId = null;

                    if (isDM) {
                        partnerId = chatDoc.members.find(member => member !== uid);
                        const partnerPublicId = currentUserData.friends[partnerId] || 'Unknown';
                        chatName = getFriendNickname(partnerId, partnerPublicId);
                        iconClass = 'fas fa-user';
                    } else {
                        chatName = chatDoc.name || 'Group Chat';
                        iconClass = 'fas fa-users';
                    }
                    return renderChatItemHtml(chatDoc, chatName, iconClass, partnerId, chatDoc.members);
                }).join('');

                dom.activeListItems.innerHTML = html;
            }, (error) => {
                console.error("Error listening to chats:", error);
                dom.activeListItems.innerHTML = '<p class="p-4 text-center text-red-400">Failed to load chats.</p>';
            });
        }

        async function renderFriends() {
            unsubscribeChats(); // Ensure we stop listening to chats
            dom.activeListItems.innerHTML = '<p class="p-4 text-center text-gray-500">Loading friends...</p>';
            
            const friendUids = Object.keys(currentUserData.friends || {});
            if (friendUids.length === 0) {
                dom.activeListItems.innerHTML = '<p class="p-4 text-center text-gray-500">You have no friends yet. Add one!</p>';
                return;
            }
            
            // Filter out friends who are also in the blocked list (shouldn't happen if block logic is correct, but safe check)
            const activeFriends = friendUids.filter(uid => !currentUserData.blocked.includes(uid));
            
            const friendPromises = activeFriends.map(uid => getDoc(doc(db, 'users', uid)));
            const friends = (await Promise.all(friendPromises)).map(d => ({ uid: d.id, publicId: d.data()?.publicId || 'Unknown' }));
            
            const html = friends.map(friend => {
                const publicId = friend.publicId;
                const currentLabel = getFriendNickname(friend.uid, publicId);
                const chatId = getDmChatId(currentUser.uid, friend.uid);
                
                return `
                    <div class="compact-list-item flex items-start justify-between group" data-list-chat-id="${chatId}">
                        <div class="flex items-center flex-grow min-w-0">
                            <i class="fas fa-user text-green-400 mr-4 text-xl flex-shrink-0"></i>
                            <div class="flex flex-col min-w-0 flex-grow">
                                <span class="font-semibold text-white truncate">${escapeHtml(currentLabel)}</span>
                                <p class="text-sm text-gray-400 truncate font-mono">${escapeHtml(publicId)}</p>
                            </div>
                        </div>
                        <div class="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity ml-4 flex gap-2">
                            <button class="text-gray-500 hover:text-indigo-500 transition edit-friend-nickname-btn" data-uid="${friend.uid}" data-current-label="${currentLabel}" title="Edit Nickname">
                                <i class="fas fa-tag"></i>
                            </button>
                            <button class="text-gray-500 hover:text-yellow-500 transition block-friend-btn" data-uid="${friend.uid}" data-name="${currentLabel}" title="Block User">
                                <i class="fas fa-user-slash"></i>
                            </button>
                            <button class="text-gray-500 hover:text-red-500 transition unfriend-btn" data-uid="${friend.uid}" data-name="${currentLabel}" title="Unfriend">
                                <i class="fas fa-user-minus"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            dom.activeListItems.innerHTML = html;
        }

        // =========================================================================
        // CHAT VIEW & UI MANAGEMENT
        // =========================================================================
        
        function updateCharacterLimitDisplay() {
            if (!currentChat.id) { dom.charLimitDisplay.textContent = ''; return; }
            const isGroup = currentChat.type === 'group';
            const limit = isGroup ? CHAR_LIMIT_GC : CHAR_LIMIT_DM;
            const currentLength = dom.messageInput.value.length;
            dom.messageInput.maxLength = limit;
            dom.charLimitDisplay.textContent = `${formatCharCount(currentLength)} / ${formatCharCount(limit)}`;
            dom.charLimitDisplay.classList.toggle('text-red-400', currentLength > limit);
        }

        function openChat(chatId, type, name, partnerId = null, members = []) {
            currentChat = { id: chatId, type, name, partnerId, members: members || [] };
            dom.chatView.classList.remove('hidden');
            dom.chatHeader.textContent = name;
            dom.editLabelBtn.classList.toggle('hidden', type !== 'dm');
            dom.blockUserBtn.classList.toggle('hidden', type !== 'dm');
            dom.editGroupNameBtn.classList.toggle('hidden', type !== 'group');
            dom.manageGroupNicknamesBtn.classList.toggle('hidden', type !== 'group');
            dom.clearChatBtn.classList.remove('hidden'); 
            
            dom.activeListItems.querySelectorAll('.compact-list-item').forEach(el => el.classList.toggle('active', el.dataset.listChatId === chatId));
            dom.messagesContainer.innerHTML = '';
            dom.messageInput.focus();
            updateCharacterLimitDisplay();
            listenToMessages(chatId);
            
            // Mobile: Hide left panel
            if (window.innerWidth < 1024) {
                dom.leftPanel.classList.remove('active');
                dom.chatView.classList.remove('hidden'); // Ensure chat view is visible
            }
        }

        function closeChat() {
            if (messageObserver) messageObserver.disconnect();
            currentChat = { id: null, type: null, name: null, partnerId: null, members: [] };
            unsubscribeMessages();
            dom.chatView.classList.add('hidden');
            dom.chatHeader.textContent = 'Select a Chat';
            dom.editLabelBtn.classList.add('hidden');
            dom.blockUserBtn.classList.add('hidden');
            dom.editGroupNameBtn.classList.add('hidden');
            dom.manageGroupNicknamesBtn.classList.add('hidden');
            dom.clearChatBtn.classList.add('hidden');
            dom.messageInput.value = '';
            attachedFiles = [];
            renderFilePreviews();
            updateCharacterLimitDisplay();
            dom.activeListItems.querySelectorAll('.compact-list-item').forEach(el => el.classList.remove('active'));
            clearInterval(chatCooldownInterval);
            dom.cooldownTimer.textContent = '';
            dom.sendBtn.disabled = false;
            
            // Mobile: Show left panel
            if (window.innerWidth < 1024) {
                 dom.leftPanel.classList.add('active');
                 dom.chatView.classList.add('hidden');
            }
        }

        function handleEditNickname(partnerUid, currentLabel) {
            const newLabel = prompt(`Set a local nickname for ${currentLabel} (leave blank to clear):`, getFriendNickname(partnerUid, ''));
            if (newLabel !== null) {
                setFriendNickname(partnerUid, newLabel.trim());
                if (currentChat.partnerId === partnerUid) {
                    dom.chatHeader.textContent = getFriendNickname(partnerUid, currentUserData.friends[partnerUid]);
                }
                switchTab(currentTab);
            }
        }

        function handleListActions(e) {
            const openChatEl = e.target.closest('[data-action="open-chat"]');
            if (openChatEl) {
                const { chatId, chatType, chatName, partnerId, members } = openChatEl.dataset;
                openChat(chatId, chatType, chatName, partnerId || null, members ? members.split(',') : []);
                return;
            }
            const deleteBtn = e.target.closest('.delete-chat-btn'), unfriendBtn = e.target.closest('.unfriend-btn'),
                  blockBtn = e.target.closest('.block-friend-btn'), editFriendNickBtn = e.target.closest('.edit-friend-nickname-btn');

            if (editFriendNickBtn) handleEditNickname(editFriendNickBtn.dataset.uid, editFriendNickBtn.dataset.currentLabel);
            else if (deleteBtn) handleDeleteChat(deleteBtn.dataset.id, deleteBtn.dataset.isGroup === 'true'); 
            else if (unfriendBtn) showConfirmModal({ title: `Unfriend ${unfriendBtn.dataset.name}?`, body: `This will unfriend them and delete your DM chat.`, onConfirm: () => handleUnfriend(unfriendBtn.dataset.uid, unfriendBtn.dataset.name) });
            else if (blockBtn) handleBlockUser(blockBtn.dataset.uid, blockBtn.dataset.name);
        }

        // =========================================================================
        // AUTH & INITIALIZATION
        // =========================================================================

        function main() {
            updateTime();
            setInterval(updateTime, 1000); 
            setupEventListeners();
            signInAnonymously(auth).catch(err => dom.loadingText.textContent = 'Authentication failed. Check your Firebase config.');
            onAuthStateChanged(auth, handleAuthStateChange);
        }

        async function handleAuthStateChange(user) {
            if (user) {
                currentUser = user;
                await setupUserDocument(user);
                listenToUserDocument(user.uid);
                // After successful authentication and setup, hide loading screen
                dom.loadingScreen.style.display = 'none';
                dom.appUi.style.display = 'grid';
                switchTab('chats');
                
                 // Mobile view adjustment: if screen is small, only show left panel initially
                if (window.innerWidth < 1024) {
                    dom.leftPanel.classList.add('active');
                }
            } else {
                dom.loadingScreen.style.display = 'flex';
                dom.appUi.style.display = 'none';
            }
        }

        async function setupUserDocument(user) {
            const userRef = doc(db, 'users', user.uid);
            const userDoc = await getDoc(userRef);
            if (!userDoc.exists()) {
                const publicId = await generateUniqueId();
                await setDoc(userRef, { uid: user.uid, publicId, friends: {}, pending_requests: [], blocked: [] });
            }
        }
        
        function listenToUserDocument(uid) {
            unsubscribeUser();
            // This is one of the important onSnapshot listeners (for user data updates)
            unsubscribeUser = onSnapshot(doc(db, 'users', uid), (doc) => {
                const data = doc.data();
                if (!data) return;
                const wasFirstLoad = !currentUserData.publicId;
                currentUserData = data;
                dom.myIdDisplay.textContent = data.publicId || '...';
                renderFriendRequests(data.pending_requests || []);
                if (wasFirstLoad) listenToChats(uid); // Start listening to chats only after user data is loaded on first run
                
                // Refresh active list based on current tab
                if (currentTab === 'chats') listenToChats(uid);
                else if (currentTab === 'friends') renderFriends();
                
                if (!dom.settingsModal.classList.contains('hidden')) renderBlockedUsers();
            }, (error) => {
                 console.error("Error listening to user document:", error);
            });
        }
        
        function switchTab(tabName) {
            if (currentTab === 'chats' && tabName === 'friends') closeChat();
            currentTab = tabName;
            
            dom.chatsTabBtn.classList.toggle('bg-indigo-600', tabName === 'chats');
            dom.chatsTabBtn.classList.toggle('text-white', tabName === 'chats');
            dom.friendsTabBtn.classList.toggle('bg-indigo-600', tabName === 'friends');
            dom.friendsTabBtn.classList.toggle('text-white', tabName === 'friends');

            const isFriendsTab = tabName === 'friends';
            dom.addFriendSection.style.display = isFriendsTab ? 'block' : 'none';
            dom.groupChatControls.style.display = isFriendsTab ? 'none' : 'flex';
            
            dom.addFriendSection.classList.toggle('fade-in', isFriendsTab);
            dom.addFriendSection.classList.toggle('fade-out', !isFriendsTab);
            dom.groupChatControls.classList.toggle('fade-in', !isFriendsTab);
            dom.groupChatControls.classList.toggle('fade-out', isFriendsTab);

            if (tabName === 'chats') listenToChats(currentUser.uid);
            else if (tabName === 'friends') { unsubscribeChats(); renderFriends(); }
        }

        function setupEventListeners() {
            dom.backToChatsBtn.addEventListener('click', closeChat);
            
            // --- INPUT BEHAVIOR (Enter to send, Shift+Enter for newline) ---
            dom.messageForm.addEventListener('submit', handleMessageSubmit); 
            dom.messageInput.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleMessageSubmit(); // Enter to send
                }
            });
            // ----------------------------------------------------------------------
            
            dom.addFriendForm.addEventListener('submit', handleAddFriend); 
            dom.friendRequestsSection.addEventListener('click', handleFriendRequestAction);
            dom.blockUserBtn.onclick = () => handleBlockUser(currentChat.partnerId, currentChat.name);
            dom.clearChatBtn.onclick = handleClearChat;
            dom.editLabelBtn.onclick = () => handleEditNickname(currentChat.partnerId, currentChat.name);
            dom.editGroupNameBtn.onclick = handleEditGroupName;
            dom.manageGroupNicknamesBtn.onclick = handleManageGroupNicknames;
            dom.createGroupBtn.addEventListener('click', openGroupModal);
            dom.createGroupModalCloseBtn.addEventListener('click', closeGroupModal);
            dom.createGroupForm.addEventListener('submit', handleCreateGroup);
            dom.chatsTabBtn.addEventListener('click', () => switchTab('chats'));
            dom.friendsTabBtn.addEventListener('click', () => switchTab('friends'));
            dom.activeListItems.addEventListener('click', handleListActions);
            dom.messagesContainer.addEventListener('scroll', updateScrollButtonVisibility);
            dom.scrollToBottomBtn.addEventListener('click', () => scrollToBottom(true));
            
            // --- FILE MENU/CAMERA LOGIC ---
            dom.openFileMenuBtn.addEventListener('click', toggleFileMenu);
            dom.fileMenuImageBtn.addEventListener('click', () => { dom.fileUploadInput.click(); dom.fileMenu.classList.add('hidden'); });
            dom.fileMenuCameraBtn.addEventListener('click', () => { dom.cameraCaptureInput.click(); dom.fileMenu.classList.add('hidden'); });

            dom.fileUploadInput.addEventListener('change', handleFileSelect);
            dom.cameraCaptureInput.addEventListener('change', handleFileSelect);
            // -----------------------------
            
            dom.openSettingsBtn.onclick = showSettingsModal;
            dom.settingsModalCloseBtn.onclick = closeSettingsModal;
            dom.imageLightbox.addEventListener('click', () => hideModal(dom.imageLightbox));
            dom.messageInput.addEventListener('input', updateCharacterLimitDisplay);
            document.addEventListener('keydown', e => {
                if (e.shiftKey && e.key === 'R' && document.activeElement !== dom.messageInput) {
                    e.preventDefault();
                    document.querySelectorAll('.message-read-indicator').forEach(el => el.classList.add('visible'));
                }
            });
            document.addEventListener('keyup', e => {
                if (e.key === 'R') {
                    document.querySelectorAll('.message-read-indicator.visible').forEach(el => el.classList.remove('visible'));
                }
            });
            document.addEventListener('click', (e) => {
                // Hide file menu if clicking anywhere outside the menu/button
                if (!dom.fileMenu.classList.contains('hidden') && 
                    e.target !== dom.fileMenu &&
                    !dom.fileMenu.contains(e.target) && 
                    e.target !== dom.openFileMenuBtn && 
                    !dom.openFileMenuBtn.contains(e.target)) {
                    dom.fileMenu.classList.add('hidden');
                }
            });
        }
        
        main();
    </script>
</body>
</html>
