<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4SP - DICTIONARY</title>
    <meta name="description" content="A simple interactive dictionary with search and definition display using dictionaryapi.dev.">

    <!-- Fonts, Icons, and Tailwind CSS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Geist Font (Main text) -->
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
    <!-- Playfair Display Italic (Special text: Pronunciation) -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Note: navigation.js and injector.js need to be in the parent directory as they use relative paths -->
    <script src="../navigation.js"></script> 
    <script src="../injector.js"></script>

    <style>
        /* --- FONT & BASE STYLING (MATCHING navigation.js) --- */
        :root {
            /* Define dark theme colors for easy reuse */
            --background-dark: #111827; /* Tailwind gray-900 */
            --card-dark: #1f2937; /* Tailwind gray-800 */
            --text-light: #f9fafb; /* Tailwind gray-50 */
            --text-muted: #9ca3af; /* Tailwind gray-400 */
            --indigo-600: #4f46e5;
        }

        body { 
            font-family: 'Geist', sans-serif; 
            background-color: var(--background-dark); 
            color: var(--text-light);
            /* This margin is to offset the fixed navbar height (4rem) */
            padding-top: 5rem; 
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align content to the top */
        }
        
        /* Loading Screen Style */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 1rem;
        }

        /* --- CARD AND CONTENT STYLING (New, matching component styles) --- */
        .dictionary-container {
            width: 100%;
            max-width: 48rem; /* Set a comfortable max-width for content */
            margin: 2rem auto;
            padding: 2rem;
            background-color: var(--card-dark);
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }

        /* Definition Card Styling */
        .definition-card {
            background-color: #111827; /* Inner dark background */
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        /* Search Input and Button */
        #search-input {
            background-color: var(--background-dark);
            border-color: #374151; /* gray-700 */
            color: var(--text-light);
            transition: all 0.3s;
        }
        #search-input:focus {
            border-color: var(--indigo-600);
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5); /* Indigo focus ring */
        }
        
        /* Definition Title and Phonetic */
        .word-title {
            color: var(--indigo-600);
            font-weight: 700;
            font-size: 2rem;
        }

        .phonetic-text {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            color: var(--text-muted);
        }

        /* Part of Speech Styling */
        .part-of-speech {
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.25rem;
        }

        /* Definition List */
        .definition-list li {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
            position: relative;
        }

        /* Custom bullet point */
        .definition-list li::before {
            content: 'â€¢';
            color: var(--indigo-600);
            font-weight: 800;
            position: absolute;
            left: 0;
            top: 0;
            font-size: 1.25rem;
        }

        /* Example Text */
        .example-text {
            color: var(--text-muted);
            font-style: italic;
            margin-top: 0.5rem;
            padding-left: 0.5rem;
            border-left: 3px solid rgba(79, 70, 229, 0.5);
        }

        /* Synonym/Antonym Tags */
        .tag {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            margin: 0.25rem;
            border-radius: 9999px;
            font-size: 0.8rem;
            background-color: rgba(79, 70, 229, 0.2); /* Indigo tint */
            color: var(--indigo-600);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .tag:hover {
            background-color: rgba(79, 70, 229, 0.4);
        }

        /* Audio Button */
        #audio-button {
            transition: background-color 0.2s, transform 0.1s;
        }
        #audio-button:hover {
            background-color: var(--indigo-600);
            transform: translateY(-1px);
        }

    </style>
    
    <!-- Global variables must be defined before use -->
    <script>
        const __app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-dictionary-app';
        const __firebase_config = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
        const __initial_auth_token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    </script>
</head>
<body>
    
    <!-- Loading Screen (Always visible initially) -->
    <div id="loading-screen" class="hidden">
        <i class="fas fa-spinner fa-spin text-indigo-500 text-4xl"></i>
        <p class="text-gray-400">Loading essential services...</p>
    </div>

    <!-- Page Content (Hidden until authenticated) -->
    <div id="page-content" class="hidden w-full">
        <div class="dictionary-container">
            <h1 class="text-3xl font-bold mb-6 text-center text-white">Interactive Dictionary</h1>
            
            <!-- Search Bar -->
            <div class="flex space-x-3 mb-8">
                <input type="text" id="search-input" placeholder="Search for a word..."
                       class="flex-grow p-3 rounded-lg border focus:outline-none"
                       value="developer"> <!-- Default search term -->
                <button id="search-button"
                        class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-3 px-5 rounded-lg transition duration-200 shadow-md hover:shadow-lg">
                    <i class="fa-solid fa-magnifying-glass"></i>
                </button>
            </div>

            <!-- Definition Display Area -->
            <div id="definition-output" class="min-h-[10rem] flex items-center justify-center">
                <p class="text-gray-500 italic">Enter a word above to see its definition.</p>
            </div>
        </div>
    </div>

    <!-- Firebase and Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global constants and initializations
        const DICTIONARY_API_URL = "https://api.dictionaryapi.dev/api/v2/entries/en/";
        const firebaseConfig = JSON.parse(__firebase_config);
        const initialAuthToken = __initial_auth_token;

        // UI elements
        const loadingScreen = document.getElementById('loading-screen');
        const pageContent = document.getElementById('page-content');
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const definitionOutput = document.getElementById('definition-output');

        // Initial setup
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Utility Functions ---

        /**
         * Converts base64 PCM audio data to a playable WAV Blob.
         * @param {string} audioDataBase64 - Base64 encoded PCM audio data.
         * @param {number} sampleRate - The sample rate (e.g., 24000).
         * @returns {Blob} - A Blob object containing the WAV file data.
         */
        const base64ToWavBlob = (audioDataBase64, sampleRate) => {
            const audioData = atob(audioDataBase64);
            const pcm16 = new Int16Array(audioData.length / 2);

            for (let i = 0; i < pcm16.length; i++) {
                // PCM data is little-endian signed 16-bit
                const low = audioData.charCodeAt(2 * i);
                const high = audioData.charCodeAt(2 * i + 1);
                pcm16[i] = (high << 8) | low;
            }
            
            const buffer = pcm16.buffer;
            
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            
            // WAV header size is 44 bytes
            const wavData = new ArrayBuffer(44 + buffer.byteLength);
            const view = new DataView(wavData);
            
            // RIFF chunk
            writeString(view, 0, 'RIFF'); // Chunk ID
            view.setUint32(4, 36 + buffer.byteLength, true); // Chunk Size
            writeString(view, 8, 'WAVE'); // Format

            // FMT sub-chunk
            writeString(view, 12, 'fmt '); // Sub-chunk 1 ID
            view.setUint32(16, 16, true); // Sub-chunk 1 Size (16 for PCM)
            view.setUint16(20, 1, true); // Audio Format (1 for PCM)
            view.setUint16(22, numChannels, true); // Num Channels
            view.setUint32(24, sampleRate, true); // Sample Rate
            view.setUint32(28, byteRate, true); // Byte Rate
            view.setUint16(32, blockAlign, true); // Block Align
            view.setUint16(34, bitsPerSample, true); // Bits Per Sample

            // DATA sub-chunk
            writeString(view, 36, 'data'); // Sub-chunk 2 ID
            view.setUint32(40, buffer.byteLength, true); // Sub-chunk 2 Size

            // Write PCM data
            const pcmView = new Int16Array(wavData, 44);
            pcmView.set(pcm16);
            
            return new Blob([view], { type: 'audio/wav' });
        };
        
        /** Helper function to write a string into a DataView */
        function writeString(view, offset, str) {
            for (let i = 0; i < str.length; i++) {
                view.setUint8(offset + i, str.charCodeAt(i));
            }
        }

        /**
         * Fetches audio for a given word using Gemini TTS API.
         * @param {string} word - The word to synthesize.
         * @returns {Promise<string|null>} - A promise that resolves to an audio URL or null on failure.
         */
        async function fetchAudio(word) {
            const prompt = `Say the word: ${word}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Achird" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API returned status ${response.status}`);
                    
                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                        // Extract sample rate from the mimeType, e.g., audio/L16;rate=24000
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                        
                        const wavBlob = base64ToWavBlob(audioData, sampleRate);
                        return URL.createObjectURL(wavBlob);
                    } else {
                        console.warn("TTS API response missing audio data or mimeType:", result);
                        return null; // Stop retrying if response structure is bad
                    }

                } catch (error) {
                    console.error(`TTS API attempt ${attempt + 1} failed:`, error);
                    if (attempt < 2) {
                        // Exponential backoff: 1s, 2s
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    }
                }
            }
            return null;
        }

        /**
         * Renders the definition in the output area.
         * @param {Array} data - Array of definition objects from the API.
         * @param {string} word - The word that was searched.
         */
        function renderDefinition(data, word) {
            if (!data || data.length === 0) {
                definitionOutput.innerHTML = `
                    <div class="text-center p-8 bg-gray-900 rounded-lg w-full">
                        <p class="text-xl font-semibold text-red-400 mb-2">Word Not Found</p>
                        <p class="text-gray-400">Sorry, we couldn't find an entry for "<strong>${word}</strong>".</p>
                        <p class="text-xs text-gray-600 mt-2">Please check the spelling and try again.</p>
                    </div>
                `;
                return;
            }

            const entry = data[0]; // Use the first available entry

            let html = `
                <div class="w-full">
                    <!-- Header: Word, Phonetic, Audio -->
                    <div class="flex items-center justify-between mb-4 pb-2 border-b border-gray-700">
                        <div>
                            <h2 class="word-title">${entry.word}</h2>
                            <p class="phonetic-text text-lg mt-1">${entry.phonetic || ''}</p>
                        </div>
                        <button id="audio-button" data-word="${entry.word}"
                                class="bg-indigo-500 text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg">
                            <i class="fa-solid fa-volume-high"></i>
                        </button>
                    </div>

                    <!-- Meanings -->
                    <div class="space-y-6">
            `;

            entry.meanings.forEach(meaning => {
                html += `
                    <div class="definition-card">
                        <h3 class="part-of-speech text-indigo-400 text-lg">${meaning.partOfSpeech}</h3>
                        <ul class="definition-list list-none space-y-3 pl-0">
                `;

                meaning.definitions.slice(0, 3).forEach((def, index) => { // Limit to 3 definitions per part of speech
                    html += `
                        <li class="text-gray-300">
                            <p class="font-medium">${def.definition}</p>
                            ${def.example ? `<p class="example-text text-sm mt-1">Example: ${def.example}</p>` : ''}
                        </li>
                    `;
                });

                html += `
                        </ul>
                        <!-- Synonyms/Antonyms -->
                        ${meaning.synonyms && meaning.synonyms.length > 0 ? `
                            <p class="text-sm text-gray-400 mt-4 mb-1">Synonyms:</p>
                            <div class="flex flex-wrap">
                                ${meaning.synonyms.slice(0, 5).map(s => `<span class="tag" data-word="${s}">${s}</span>`).join('')}
                            </div>
                        ` : ''}
                        ${meaning.antonyms && meaning.antonyms.length > 0 ? `
                            <p class="text-sm text-gray-400 mt-4 mb-1">Antonyms:</p>
                            <div class="flex flex-wrap">
                                ${meaning.antonyms.slice(0, 5).map(a => `<span class="tag" data-word="${a}">${a}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            definitionOutput.innerHTML = html;
        }

        /**
         * Fetches definition data from the external API.
         * @param {string} word - The word to search for.
         */
        async function fetchDefinition(word) {
            definitionOutput.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin text-indigo-500 text-3xl"></i><p class="text-gray-400 mt-2">Searching...</p></div>';

            try {
                const response = await fetch(`${DICTIONARY_API_URL}${word}`);
                const data = await response.json();

                if (response.ok && Array.isArray(data)) {
                    renderDefinition(data, word);
                } else if (!response.ok && data.title) {
                    // API returns a custom JSON error object if word is not found (status 404)
                    renderDefinition(null, word); 
                } else {
                    throw new Error("API returned an unexpected response structure.");
                }
            } catch (error) {
                console.error("Error fetching definition:", error);
                definitionOutput.innerHTML = `
                    <div class="text-center p-8 bg-gray-900 rounded-lg w-full">
                        <p class="text-xl font-semibold text-red-500 mb-2">Network Error</p>
                        <p class="text-gray-400">Could not reach the dictionary service. Please check your connection.</p>
                    </div>
                `;
            }
        }

        // --- Event Listeners ---

        // Search button click
        searchButton.addEventListener('click', () => {
            const word = searchInput.value.trim();
            if (word) {
                fetchDefinition(word);
            }
        });

        // Search input Enter key press
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchButton.click();
            }
        });

        // Delegation for audio button and synonym/antonym tags
        definitionOutput.addEventListener('click', async (e) => {
            let target = e.target;
            
            // Handle audio playback
            if (target.id === 'audio-button' || target.closest('#audio-button')) {
                const button = target.closest('#audio-button');
                const word = button.getAttribute('data-word');

                if (word) {
                    button.disabled = true;
                    button.classList.add('opacity-50');

                    // If audio URL already exists, use it
                    let audioUrl = button.getAttribute('data-audio-url');
                    
                    if (!audioUrl) {
                        audioUrl = await fetchAudio(word);
                        button.setAttribute('data-audio-url', audioUrl || '');
                    }

                    if (audioUrl) {
                        const audio = new Audio(audioUrl);
                        audio.play().catch(err => console.error("Audio playback failed:", err));
                    }
                    
                    button.disabled = false;
                    button.classList.remove('opacity-50');
                }
                return;
            }

            // Handle tag click for new search
            let wordToSearch = null;
            if (target.classList.contains('tag')) {
                wordToSearch = target.getAttribute('data-word');
            }
            
            if (wordToSearch) {
                // Update the input field
                searchInput.value = wordToSearch;
                // Perform the new search
                fetchDefinition(wordToSearch);
            }
        });


        // --- Core Authentication and Redirection Logic (Copied from base-template.html) ---
        async function initializeAuth() {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Initial Firebase authentication failed:", error);
            }
        }

        // 1. Listen for the authentication state change
        onAuthStateChanged(auth, (user) => {
            if (user) {
                // User is authenticated
                console.log("User authenticated. UID:", user.uid);
                
                // Hide loading screen and show content
                loadingScreen.classList.add('hidden');
                pageContent.classList.remove('hidden');

                // Initial search on load with the default value
                fetchDefinition(searchInput.value.trim());

            } else {
                // User is NOT authenticated. Redirect to login/index page.
                console.log("User not authenticated. Redirecting to ../index.html...");
                window.location.href = '../index.html'; 
            }
        });

        // 2. Start the authentication process on load
        // Initial setup for the loading screen before auth begins
        loadingScreen.classList.remove('hidden');
        pageContent.classList.add('hidden');
        initializeAuth();
        
    </script>
</body>
</html>
