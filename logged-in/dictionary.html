<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4SP - Interactive Dictionary</title>
    <meta name="description" content="A simple interactive dictionary with search and definition display using freedictionaryapi.com.">

    <!-- Fonts, Icons, and Tailwind CSS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Geist Font (Main text) -->
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
    <!-- Playfair Display Italic (Special text: Pronunciation) -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="../navigation.js"></script>
    <script src="../injector.js"></script>

    <style>
        /* --- FONT & BASE STYLING (MATCHING base-template.html) --- */
        body { 
            font-family: 'Geist', sans-serif; 
            background-color: #070707; 
            color: #c0c0c0; 
            transition: all 0.3s ease;
            font-weight: 300; 
            min-height: 100vh;
        }
        
        h1, h2, h3, .font-bold, .font-semibold, strong, .tracking-widest {
            font-weight: 400 !important;
        }

        /* Styling for the main content container */
        .page-container {
            padding: 2rem 1rem;
            max-width: 900px; /* Narrower for focus */
            margin: 0 auto;
        }

        /* Placeholder content box replaced with a general dictionary card */
        .dictionary-card {
            background-color: #111111; 
            border: 1px solid #252525; 
            border-radius: 0.75rem; 
            padding: 2rem; 
            min-height: 70vh;
        }

        /* Standard loading screen style */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #070707;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        /* --- CUSTOM DICTIONARY STYLING --- */
        .pronunciation-text {
            /* Special font for pronunciation */
            font-family: 'Playfair Display', serif;
            font-style: italic;
            color: #9ca3af; /* Initial muted gray for visibility */
            transition: color 0.2s ease;
            cursor: help; 
        }

        .pronunciation-text:hover {
            /* Cyan color on hover */
            color: #06b6d4; /* Tailwind cyan-500 equivalent */
        }
        
        .highlighted-word {
            /* Styling for clickable words within the definition text */
            text-decoration: underline;
            text-decoration-color: #06b6d480; /* semi-transparent cyan */
            text-underline-offset: 3px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        
        .highlighted-word:hover {
            background-color: #06b6d420; /* light cyan background on hover */
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <!-- Loading Screen (Shown until authentication check is complete) -->
    <div id="loading-screen">
        <p class="text-xl text-gray-400">Verifying authentication...</p>
    </div>

    <!-- Main Page Content (Hidden until authenticated) -->
    <main id="page-content" class="page-container hidden">
        <div class="dictionary-card shadow-xl">
            <h1 class="text-3xl font-bold text-white mb-6 text-center">Interactive Lexicon</h1>

            <!-- Search Bar (Integrated, rounded-xl input, button inside) -->
            <div class="relative mb-8">
                <!-- Input Field (Rounded-xl) -->
                <input 
                    type="text"
                    id="search-input"
                    placeholder="Type a word and press Enter or click the Search icon..."
                    class="w-full p-4 pl-12 pr-20 rounded-xl bg-zinc-800 text-white border border-zinc-700 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition duration-150"
                    autocomplete="off"
                />
                <!-- Book Icon inside input -->
                <i class="fas fa-book absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                
                <!-- Search Button (Squircle, integrated, right side, using fa-paper-plane) -->
                <button 
                    id="search-button" 
                    class="absolute right-2 top-1/2 transform -translate-y-1/2 w-12 h-12 bg-cyan-600 hover:bg-cyan-700 text-white font-semibold rounded-[1rem] shadow-md transition duration-150 active:scale-[.98] flex items-center justify-center"
                    title="Search Dictionary">
                    <!-- Send Message Icon -->
                    <i class="fas fa-paper-plane text-lg"></i>
                </button>
            </div>

            <!-- Definition Display -->
            <div id="definition-output" class="p-6 bg-zinc-900 border border-zinc-800 rounded-lg min-h-[30vh]">
                <p class="text-lg text-gray-400 text-center">
                    Enter a word above and hit **Search** or **Enter** to look up its definition, pronunciation, and synonyms using the dictionary API.
                </p>
            </div>
            
        </div>
    </main>

    <script type="module">
        // --- Firebase Core Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        
        // --- CONFIGURATION IMPORT ---
        // NOTE: This assumes you have a firebase-config.js file one level up (../)
        import { firebaseConfig } from "../firebase-config.js"; 
        
        // --- Canvas Global Variables (MANDATORY USE) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const rawFirebaseConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let config = firebaseConfig;
        if (rawFirebaseConfig) {
            try {
                config = JSON.parse(rawFirebaseConfig);
            } catch (e) {
                console.error("Failed to parse __firebase_config:", e);
            }
        }

        // --- Initialize Firebase ---
        const app = initializeApp(config);
        const auth = getAuth(app);

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const pageContent = document.getElementById('page-content');
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const definitionOutput = document.getElementById('definition-output');
        
        // --- DICTIONARY API LOGIC ---
        
        /**
         * Fetches the definition for a given word using the freedictionaryapi.com API.
         * @param {string} word The word to look up.
         */
        async function fetchDefinition(word) {
            const trimmedWord = word.trim().toLowerCase();
            if (!trimmedWord) return;

            // 1. Set loading state and clear input field
            definitionOutput.innerHTML = `
                <p class="text-xl text-cyan-400 text-center flex items-center justify-center space-x-2">
                    <i class="fas fa-spinner fa-spin mr-2"></i><span>Searching for '${trimmedWord}'...</span>
                </p>
            `;
            searchInput.value = trimmedWord; // Set the input field to the word being searched

            try {
                // API ENDPOINT: The previous one was fine and should work for the new structure too.
                const url = `https://api.freedictionaryapi.com/api/v1/entries/en/${trimmedWord}`;
                const response = await fetch(url);

                if (!response.ok) {
                    // API returns 404 for words not found
                    if (response.status === 404) {
                        definitionOutput.innerHTML = `
                            <p class="text-xl text-red-400 text-center">
                                Sorry, we couldn't find a definition for <strong>"${trimmedWord}"</strong>. Please check the spelling.
                            </p>
                        `;
                    } else {
                        // Handle other HTTP errors
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return;
                }

                const data = await response.json();
                
                // The API can return an error object inside the data array if the structure doesn't match the expected.
                if (Array.isArray(data) && data.length > 0 && data[0].hasOwnProperty('title')) {
                     definitionOutput.innerHTML = `
                        <p class="text-xl text-red-400 text-center">
                            Sorry, we couldn't find a definition for <strong>"${trimmedWord}"</strong>. Please check the spelling.
                        </p>
                    `;
                    return;
                }

                displayDefinition(trimmedWord, data);

            } catch (error) {
                console.error("Fetch error:", error);
                definitionOutput.innerHTML = `
                    <p class="text-xl text-red-400 text-center">
                        An unexpected error occurred while fetching the definition. Please try again later.
                    </p>
                `;
            }
        }

        /**
         * Replaces standalone words (4+ chars) in the definition text with clickable spans.
         * Excludes an expanded list of common function words, focusing on conceptual words.
         * @param {string} text The definition text.
         * @returns {string} The text with clickable links.
         */
        function highlightDefinitionText(text) {
            // List of common words to exclude from linking. This list is heavily optimized to filter out all 
            // function words and common non-conceptual words, focusing only on nouns, core verbs, and descriptive adjectives.
            const commonWords = [
                // Articles, Conjunctions, Prepositions (short & common)
                'the', 'and', 'but', 'not', 'for', 'with', 'from', 'into', 'upon', 'like', 
                'than', 'only', 'much', 'about', 'just', 'over', 'under', 'also', 'some', 'such', 
                'through', 'without', 'before', 'after', 'among', 'between', 'where', 'whether', 
                'since', 'still', 'though', 'towards', 'unless', 'below', 'above', 'near', 'far',
                'along', 'across', 'against', 'amongst', 'around', 'behind', 'beside', 'beyond',
                'during', 'except', 'inside', 'outside', 'past', 'round', 'toward', 'until', 
                'while', 'whereas', 'whilst', 'whereby', 'wherein', 'whereof', 'wherever', 'whichever',
                'whenever', 'wherever', 'because', 'towards', 'amid', 'onto', 'per',
                
                // Pronouns & Demonstratives
                'that', 'this', 'you', 'any', 'all', 'they', 'them', 'their', 'your', 'most',
                'which', 'what', 'whose', 'whom', 'there', 'here', 'these', 'those', 'itself',
                'herself', 'himself', 'myself', 'yourself', 'its', 'ours', 'yours', 'theirs', 'us',
                'him', 'her', 'how', 'when', 'why', 'whose', 'something', 'anything', 'everything', 'none',

                // Auxiliary/Modal Verbs & Common Verbs
                'have', 'will', 'was', 'are', 'can', 'use', 'make', 'take', 'look', 'find', 
                'must', 'should', 'could', 'would', 'become', 'may', 'might', 'shall', 'been',
                'being', 'does', 'doing', 'did', 'gets', 'give', 'went', 'come', 'said', 'say',
                'says', 'keep', 'keeps', 'move', 'moves', 'used', 'using', 'makes', 'takes',
                'looks', 'finds', 'given', 'taken', 'become', 'becomes', 'being', 'having',
                'going', 'comes', 'seen', 'knew', 'know', 'knows', 'feel', 'felt', 'feelings',
                'seem', 'seems', 'seemed', 'using', 'used', 'get', 'gives', 'gave', 'goes', 'went',

                // Common Adverbs & Adjectives (non-conceptual) & fillers
                'very', 'even', 'only', 'always', 'often', 'never', 'ever', 'away', 'down', 'more',
                'other', 'little', 'less', 'same', 'high', 'low', 'back', 'good', 'well', 'bad', 
                'full', 'empty', 'next', 'last', 'first', 'second', 'third', 'main', 'chief',
                'great', 'small', 'large', 'tiny', 'huge', 'early', 'late', 'quick', 'slow',
                'surely', 'truly', 'really', 'simply', 'mostly', 'mainly', 'simply', 'oftenly',
                'nearly', 'hardly', 'merely', 'either', 'neither', 'else', 'still', 'alone',
                'enough', 'where', 'when', 'how', 'why', 'further', 'several', 'various', 'various', 
                'certain', 'specific', 'general', 'primary', 'secondary', 'tertiary', 'many', 'few',
                'little', 'least', 'most', 'another', 'own', 'every', 'each', 'whole', 'entire',
                'total', 'overall', 'ready', 'able', 'possible', 'impossible', 'likely', 'unlikely'
            ];
            
            // Regex continues to find standalone words that are 4 characters or more ({4,})
            return text.replace(/\b([a-zA-Z]{4,})\b/g, (match) => {
                if (commonWords.includes(match.toLowerCase())) {
                    return match;
                }

                // Wrap the word in a clickable span. Using `data-word` attribute for lookup.
                return `<span 
                            class="highlighted-word text-cyan-400 hover:text-cyan-200 cursor-pointer font-medium" 
                            data-word="${match.toLowerCase()}">${match}</span>`;
            });
        }


        /**
         * Renders the definition data onto the page, adapted for the entries/senses structure.
         * @param {string} word The word being displayed.
         * @param {Object} data The definition object from the API.
         */
        function displayDefinition(word, data) {
            
            // 1. Get the main entry object
            const entry = data.entries?.[0]; // Access the first entry within the data object
            
            if (!entry || !entry.partOfSpeech || !entry.partOfSpeech.length) {
                definitionOutput.innerHTML = `<p class="text-xl text-red-400 text-center">No detailed definition entries found for "${word}".</p>`;
                return;
            }

            // 2. Extract Phonetic Text from the main entry (assuming the pronunciations array is at the entry level)
            // Path: data[0].entries[0].pronunciations[i].text
            const phoneticText = entry.pronunciations?.find(p => p.text)?.text || 'N/A';
            
            let htmlContent = `
                <div class="space-y-6">
                    <h2 class="text-4xl font-semibold text-cyan-400 capitalize mb-1">${word}</h2>
                    <p class="text-xl text-gray-400">
                        <span class="pronunciation-text" title="Pronunciation">${phoneticText}</span>
                    </p>
                    <hr class="border-zinc-700" />
            `;
            
            // 3. Iterate through all parts of speech (partOfSpeech is now an array in the new structure)
            entry.partOfSpeech.forEach(posEntry => {
                // Ensure the POS entry has senses
                if (!posEntry.senses || posEntry.senses.length === 0) return;

                htmlContent += `
                    <div class="space-y-4 mb-8">
                        <h3 class="text-2xl font-semibold text-indigo-300 border-l-4 border-indigo-500 pl-3">
                            ${posEntry.partOfSpeech.charAt(0).toUpperCase() + posEntry.partOfSpeech.slice(1)}
                        </h3>
                        
                        <!-- Definitions Section Header and Numbered List -->
                        <div class="ml-4">
                            <h4 class="text-xl font-medium text-white mb-2 pb-1 border-b border-zinc-700">Definitions</h4>
                            <ol class="list-decimal list-inside space-y-3 pl-4">
                `;

                // 4. Iterate through all senses for this part of speech
                posEntry.senses.slice(0, 3).forEach((sense) => { 
                    const definitionText = sense.definition || 'No definition provided.';
                    const highlightedDefinition = highlightDefinitionText(definitionText);
                    
                    // The example is an array of strings in the new structure. Use the first one.
                    const exampleText = sense.examples?.[0]; 

                    // Synonyms are also an array of strings at the sense level
                    const senseSynonyms = sense.synonyms || [];
                    
                    htmlContent += `
                        <li>
                            <div class="space-y-1">
                                <p class="text-gray-300">${highlightedDefinition}</p>
                    `;
                    
                    // Conditionally add example
                    if (exampleText) {
                        htmlContent += `
                            <hr class="border-zinc-800 mt-2 mb-1 w-full" /> 
                            <p class="text-sm text-gray-500 italic">e.g. "${exampleText}"</p>
                        `;
                    }
                    
                    // Conditionally add synonyms
                    if (senseSynonyms.length > 0) {
                         const synonymTags = senseSynonyms.slice(0, 5).map(s => 
                            `<span 
                                class="px-3 py-1 bg-zinc-700 text-cyan-200 rounded-lg text-sm font-semibold cursor-pointer hover:bg-zinc-600 transition synonym-tag"
                                data-word="${s}"
                            >${s}</span>`
                        ).join(' ');

                        htmlContent += `
                            <div class="mt-2 text-sm">
                                <span class="text-white font-semibold mr-2">Synonyms:</span>
                                <span class="flex flex-wrap gap-1 mt-1">${synonymTags}</span>
                            </div>
                        `;
                    }


                    htmlContent += `</div></li>`;
                });

                htmlContent += `</ol></div>`; // Close definitions ol and surrounding div
                htmlContent += `</div>`; // Close partOfSpeech div
            });

            htmlContent += `</div>`; // Close space-y-6 div
            definitionOutput.innerHTML = htmlContent;
        }

        // --- EVENT HANDLERS ---
        
        /** Handler for Enter key press in the search box */
        function handleInputKeyDown(event) {
            if (event.key === 'Enter') {
                handleSearchClick();
            }
        }
        
        /** Handler for Search button click */
        function handleSearchClick() {
            const query = searchInput.value.trim().toLowerCase();
            if (query) {
                fetchDefinition(query);
            } else {
                definitionOutput.innerHTML = `<p class="text-lg text-gray-400 text-center">Please enter a word to search.</p>`;
            }
        }


        // --- EVENT LISTENERS ---
        searchInput.addEventListener('keydown', handleInputKeyDown);
        searchButton.addEventListener('click', handleSearchClick);

        // --- Event Delegation for Clickable Words (Synonyms and Definition Highlights) ---
        definitionOutput.addEventListener('click', (event) => {
            const target = event.target;
            let wordToSearch = null;

            if (target.classList.contains('synonym-tag')) {
                wordToSearch = target.getAttribute('data-word');
            } else if (target.classList.contains('highlighted-word')) {
                wordToSearch = target.getAttribute('data-word');
            }
            
            if (wordToSearch) {
                // Perform the new search
                fetchDefinition(wordToSearch);
            }
        });


        // --- Core Authentication and Redirection Logic (Copied from base-template.html) ---
        async function initializeAuth() {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Initial Firebase authentication failed:", error);
            }
        }

        // 1. Listen for the authentication state change
        onAuthStateChanged(auth, (user) => {
            if (user) {
                // User is authenticated
                console.log("User authenticated. UID:", user.uid);
                
                // Hide loading screen and show content
                loadingScreen.style.display = 'none';
                pageContent.classList.remove('hidden');

            } else {
                // User is NOT authenticated. Redirect to login/index page.
                console.log("User not authenticated. Redirecting to ../index.html...");
                window.location.href = '../index.html'; 
            }
        });

        // 2. Start the authentication process on load
        initializeAuth();
        
    </script>
</body>
</html>
