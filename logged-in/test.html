<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4SP - Messenger V2.7 (Enhanced Chat)</title>
    <meta name="description" content="A secure, peer-to-peer messenger with group chat functionality, friend requests, and enhanced features.">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* --- FONT & BASE STYLING --- */
        body { 
            font-family: 'Geist', sans-serif; 
            background-color: #070707; 
            color: #c0c0c0; 
            transition: all 0.3s ease;
            font-weight: 300; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        h1, h2, h3, .font-bold, .font-semibold, strong {
            font-weight: 600;
        }

        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #3b82f644; border-radius: 10px; }
        .dark ::-webkit-scrollbar-thumb { background: #3b82f688; }

        /* Read Receipt Avatar Style */
        .read-receipt-avatar {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            border: 2px solid #1f2937; /* Background color of the chat bubble container */
            transition: transform 0.2s ease;
        }

        /* Message input area fixes */
        #message-input-area {
            position: relative;
            padding-right: 1.5rem; /* Space for the character limit display */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <!-- Main App Container -->
    <div id="app-container" class="flex-grow flex h-screen bg-gray-900 text-gray-200">

        <!-- Sidebar/Contacts (Always visible) -->
        <div id="sidebar" class="w-1/3 max-w-xs md:max-w-md bg-gray-800 flex flex-col border-r border-gray-700">
            <header class="p-4 flex flex-col">
                <h1 class="text-2xl font-bold text-blue-400">4SP Chat</h1>
                <div class="mt-2 text-xs flex items-center bg-gray-700 p-2 rounded-lg">
                    <span class="mr-2 text-blue-300">Your ID:</span>
                    <code id="my-id" class="flex-grow truncate font-mono text-gray-400">...</code>
                    <button id="copy-id-btn" class="ml-2 text-sm text-blue-400 hover:text-blue-300 transition duration-150"><i class="fas fa-copy"></i></button>
                </div>
            </header>

            <!-- Friend/Group List -->
            <div class="p-4 border-b border-gray-700 flex space-x-2">
                <button id="add-contact-btn" class="flex-grow p-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition duration-150 shadow-md">
                    <i class="fas fa-user-plus"></i> Add Contact
                </button>
                <button id="open-settings-btn" class="p-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition duration-150 shadow-md" title="Settings">
                    <i class="fas fa-cog"></i>
                </button>
            </div>

            <div id="contacts-list" class="flex-grow overflow-y-auto">
                <p class="text-center text-gray-500 p-4">Loading contacts...</p>
            </div>
        </div>

        <!-- Chat Window (Starts hidden for mobile) -->
        <div id="chat-window" class="flex-grow flex-col hidden md:flex">
            <!-- Chat Header -->
            <header id="chat-header" class="p-4 bg-gray-800 border-b border-gray-700 flex items-center justify-between shadow-lg">
                <div class="flex items-center">
                    <button id="back-to-contacts-btn" class="md:hidden mr-4 text-gray-400 hover:text-white"><i class="fas fa-arrow-left"></i></button>
                    <h2 id="chat-partner-name" class="text-xl font-semibold">Select a Chat</h2>
                </div>
                <div id="chat-actions" class="text-sm space-x-3">
                    <span id="chat-type-indicator" class="px-2 py-1 bg-blue-500 text-white rounded-full text-xs hidden">Private</span>
                    <button id="leave-group-btn" class="text-red-400 hover:text-red-500 hidden" title="Leave Group"><i class="fas fa-sign-out-alt"></i></button>
                </div>
            </header>

            <!-- Message Area -->
            <div id="messages-container" class="flex-grow p-4 overflow-y-auto space-y-4 relative">
                <!-- Messages will be rendered here -->
                <div id="messages-list">
                    <p class="text-center text-gray-500">No messages yet. Say hello!</p>
                </div>

                <!-- Scroll to Bottom Button -->
                <button id="scroll-to-bottom-btn" class="fixed right-8 bottom-28 w-10 h-10 bg-blue-500 text-white rounded-full shadow-lg opacity-0 pointer-events-none transition-opacity duration-300">
                    <i class="fas fa-arrow-down"></i>
                </button>
                
                <!-- Read Receipts Info Box -->
                <div id="read-receipts-info" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-700 text-sm text-white px-4 py-2 rounded-lg shadow-xl transition-opacity duration-300 opacity-0 pointer-events-none z-50">
                    <i class="fas fa-eye mr-2"></i> Read Receipts View ON (Shift + R)
                </div>
            </div>

            <!-- Message Input Form -->
            <div id="message-input-area" class="p-4 bg-gray-800 border-t border-gray-700">
                <div id="image-preview-container" class="flex flex-wrap gap-2 p-2 bg-gray-700 rounded-t-lg hidden mb-2">
                    <!-- Image previews go here -->
                </div>
                <form id="message-form" class="flex items-end space-x-2">
                    <input type="file" id="file-upload-input" accept="image/*" multiple class="hidden">
                    <button type="button" id="attach-file-btn" class="p-3 text-blue-400 hover:text-blue-300 transition duration-150" title="Attach Image">
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <textarea id="message-input" rows="1" class="flex-grow p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:border-blue-500 resize-none max-h-40" placeholder="Type a message..."></textarea>
                    
                    <div class="absolute bottom-2 right-14 text-xs text-gray-400 font-mono" id="char-limit-display">
                        10K
                    </div>

                    <button type="submit" id="send-btn" class="p-3 bg-blue-600 hover:bg-blue-700 text-white rounded-full shadow-lg transition duration-150 w-12 h-12 flex items-center justify-center">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
            </div>
        </div>

        <!-- Placeholder for Unselected Chat -->
        <div id="unselected-chat-placeholder" class="flex-grow hidden md:flex items-center justify-center">
            <p class="text-xl text-gray-500">Select a contact to start chatting</p>
        </div>
    </div>

    <!-- Modals (Add Contact, Confirm, Settings) -->
    <!-- Add Contact Modal (Keep as existing) -->
    <div id="add-contact-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center hidden opacity-0 transition-opacity duration-300">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 class="text-xl font-semibold mb-4 text-white">Add Friend or Start Group</h3>
            <div id="add-friend-message" class="mb-4 hidden p-3 rounded-lg text-sm"></div>
            <input type="text" id="friend-id-input" placeholder="Enter Friend's ID or Group Name" class="w-full p-3 mb-4 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none">
            <div class="flex justify-end space-x-3">
                <button id="add-contact-close-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg text-white">Cancel</button>
                <button id="submit-add-contact-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-white">Submit</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal (General purpose confirmation) -->
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center hidden opacity-0 transition-opacity duration-300">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 id="confirm-modal-title" class="text-xl font-semibold mb-4 text-white">Confirmation</h3>
            <p id="confirm-modal-body" class="mb-6 text-gray-300">Are you sure?</p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-modal-cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg text-white">Cancel</button>
                <button id="confirm-modal-confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center hidden opacity-0 transition-opacity duration-300">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-lg">
            <h3 class="text-2xl font-semibold mb-6 text-white border-b border-gray-700 pb-2">Settings & Block List</h3>
            
            <div class="mb-6">
                <h4 class="text-lg font-medium mb-3 text-blue-400">Blocked Users</h4>
                <ul id="blocked-users-list" class="space-y-2 max-h-60 overflow-y-auto bg-gray-700 p-3 rounded-lg">
                    <!-- Blocked users will be rendered here -->
                    <p class="text-sm text-gray-400">No users blocked.</p>
                </ul>
            </div>
            
            <div class="flex justify-end">
                <button id="settings-modal-close-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg text-white">Close</button>
            </div>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, arrayUnion, arrayRemove, serverTimestamp, writeBatch, limit, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONFIG & CONSTANTS ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const __initial_auth_token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const PRIVATE_CHAR_LIMIT = 10000;
        const GROUP_CHAR_LIMIT = 5000;
        const PRIVATE_IMAGE_LIMIT = 5;
        const GROUP_IMAGE_LIMIT = 3;
        const PROFANITY_API_KEY = ""; // Replace with your profanityapi.dev key if needed
        const GROUP_COOLDOWN_MS = 2000;

        let db, auth;
        let currentUser;
        let currentChatId = null;
        let currentChat = null;
        let attachedFiles = [];
        let isGroupChatCooldown = false;
        let chatUnsubscribe = null;
        let readReceiptsUnsubscribe = null;
        let showReadReceipts = false; // New state for Shift+R

        // A map to store user profiles for efficient lookup: { uid: { name, avatar } }
        let userCache = {}; 
        
        // --- DOM ELEMENTS ---
        const dom = {
            // Main UI
            appContainer: document.getElementById('app-container'),
            sidebar: document.getElementById('sidebar'),
            chatWindow: document.getElementById('chat-window'),
            unselectedPlaceholder: document.getElementById('unselected-chat-placeholder'),
            
            // Chat Header
            chatHeader: document.getElementById('chat-header'),
            chatPartnerName: document.getElementById('chat-partner-name'),
            chatTypeIndicator: document.getElementById('chat-type-indicator'),
            backToContactsBtn: document.getElementById('back-to-contacts-btn'),
            leaveGroupBtn: document.getElementById('leave-group-btn'),

            // Self ID
            myIdEl: document.getElementById('my-id'),
            copyIdBtn: document.getElementById('copy-id-btn'),

            // Message Area
            messagesContainer: document.getElementById('messages-container'),
            messagesList: document.getElementById('messages-list'),
            scrollToBottomBtn: document.getElementById('scroll-to-bottom-btn'),
            readReceiptsInfo: document.getElementById('read-receipts-info'),

            // Message Form
            messageForm: document.getElementById('message-form'),
            messageInput: document.getElementById('message-input'),
            sendBtn: document.getElementById('send-btn'),
            charLimitDisplay: document.getElementById('char-limit-display'),
            attachFileBtn: document.getElementById('attach-file-btn'),
            fileUploadInput: document.getElementById('file-upload-input'),
            imagePreviewContainer: document.getElementById('image-preview-container'),

            // Contacts/Friends
            addContactBtn: document.getElementById('add-contact-btn'),
            contactsListEl: document.getElementById('contacts-list'),

            // Modals
            addContactModal: document.getElementById('add-contact-modal'),
            addContactCloseBtn: document.getElementById('add-contact-close-btn'),
            submitAddContactBtn: document.getElementById('submit-add-contact-btn'),
            addFriendMessage: document.getElementById('add-friend-message'),
            friendIdInput: document.getElementById('friend-id-input'),
            confirmModal: document.getElementById('confirm-modal'),
            confirmModalTitle: document.getElementById('confirm-modal-title'),
            confirmModalBody: document.getElementById('confirm-modal-body'),
            confirmModalCancelBtn: document.getElementById('confirm-modal-cancel-btn'),
            confirmModalConfirmBtn: document.getElementById('confirm-modal-confirm-btn'),
            settingsModal: document.getElementById('settings-modal'),
            settingsModalCloseBtn: document.getElementById('settings-modal-close-btn'),
            blockedUsersList: document.getElementById('blocked-users-list'),
            openSettingsBtn: document.getElementById('open-settings-btn'),
        };

        // --- UTILITY FUNCTIONS ---

        /** Shows a temporary message banner. */
        function showMessage(element, message, type = 'info') {
            element.textContent = message;
            element.classList.remove('hidden', 'bg-red-800', 'bg-green-800', 'text-red-300', 'text-green-300');
            if (type === 'error') {
                element.classList.add('bg-red-800', 'text-red-300');
            } else if (type === 'success') {
                element.classList.add('bg-green-800', 'text-green-300');
            } else {
                element.classList.add('bg-gray-700', 'text-gray-300');
            }
            clearTimeout(element.timer);
            element.timer = setTimeout(() => element.classList.add('hidden'), 3000);
        }

        /** Formats a number (like character limit) using abbreviations (1000 -> 1K). */
        function formatLimit(num) {
            if (num >= 1000) {
                return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            }
            return num.toString();
        }

        /** Converts a File object to a Data URL (base64). */
        function fileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        /** Compresses an image data URL using a Canvas. */
        function compressImage(dataURL, maxWidth, maxHeight, quality = 0.8) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxWidth) {
                            height = height * (maxWidth / width);
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width = width * (maxHeight / height);
                            height = maxHeight;
                        }
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Convert canvas to a compressed JPEG Data URL
                    resolve(canvas.toDataURL('image/jpeg', quality));
                };
                img.src = dataURL;
            });
        }

        /** Profanity check using external API (Group Chats only) */
        async function checkProfanity(text) {
            if (!PROFANITY_API_KEY) {
                console.warn("Profanity API Key is missing. Skipping profanity check.");
                return { isProfane: false, text };
            }

            try {
                const response = await fetch('https://api.profanityapi.dev/v1/profanity', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-KEY': PROFANITY_API_KEY,
                    },
                    body: JSON.stringify({
                        text: text,
                        language: 'en',
                        // Action: 'mark' will replace profane words with asterisks
                        action: 'mark' 
                    }),
                });

                if (!response.ok) {
                    console.error("Profanity API error:", response.statusText);
                    return { isProfane: false, text }; // Default to not profane on API error
                }

                const data = await response.json();
                
                // If there are words flagged as "bad" (score > 0), consider it profane.
                const isProfane = data.bad_words_total > 0;
                const censoredText = data.text;

                return { isProfane, text: censoredText };

            } catch (error) {
                console.error("Error checking profanity:", error);
                return { isProfane: false, text };
            }
        }


        /**
         * Retries a fetch request with exponential backoff.
         * @param {string} url 
         * @param {object} options 
         * @param {number} maxRetries 
         * @returns {Promise<Response>}
         */
        async function fetchWithBackoff(url, options = {}, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return response;
                    }
                    // Handle non-OK responses that are recoverable (e.g., 5xx)
                    if (response.status >= 500) {
                        throw new Error(`Server error: ${response.status}`);
                    }
                    // For client errors (4xx), don't retry, just throw
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error; // Re-throw on last attempt
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        // --- FIREBASE SETUP & HELPERS ---
        function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUser = user;
                        dom.myIdEl.textContent = user.uid;
                        await ensureUserProfile(user.uid);
                        setupRealtimeContactListeners();
                    } else {
                        // Sign in using custom token or anonymously
                        try {
                            if (__initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Authentication failed:", error);
                            // Fallback UI or error message if auth fails
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                dom.contactsListEl.innerHTML = '<p class="text-center text-red-400 p-4">Firebase failed to initialize. Check console for details.</p>';
            }
        }

        /** Returns the document reference for a user's profile. */
        function getUserProfileDocRef(uid) {
            return doc(db, `artifacts/${appId}/users/${uid}/profile/main`);
        }
        
        /** Returns the document reference for a chat. */
        function getChatDocRef(chatId) {
            return doc(db, `artifacts/${appId}/public/data/chats/${chatId}`);
        }

        /** Returns the collection reference for messages in a chat. */
        function getMessagesCollectionRef(chatId) {
            return collection(db, `artifacts/${appId}/public/data/chats/${chatId}/messages`);
        }
        
        /** Returns the document reference for a user's read receipt in a chat. */
        function getReadReceiptDocRef(chatId, userId) {
            return doc(db, `artifacts/${appId}/public/data/chats/${chatId}/readReceipts/${userId}`);
        }

        /** Ensures the current user has a profile document. */
        async function ensureUserProfile(uid) {
            const profileRef = getUserProfileDocRef(uid);
            const profileSnap = await getDoc(profileRef);
            
            if (!profileSnap.exists()) {
                const username = `User-${uid.substring(0, 5)}`;
                const initialProfile = { 
                    uid, 
                    username, 
                    contacts: [], // Array of chat IDs
                    friendRequests: [],
                    blockedUsers: [],
                    lastActive: serverTimestamp()
                };
                await setDoc(profileRef, initialProfile, { merge: true });
                userCache[uid] = { name: username, avatar: '👤' };
            } else {
                 userCache[uid] = { 
                    name: profileSnap.data().username || `User-${uid.substring(0, 5)}`, 
                    avatar: '👤' 
                };
            }
        }
        
        /** Fetches a user profile and caches it. */
        async function fetchAndCacheUser(uid) {
            if (userCache[uid]) return userCache[uid];
            
            const profileRef = getUserProfileDocRef(uid);
            const profileSnap = await getDoc(profileRef);
            
            if (profileSnap.exists()) {
                const data = profileSnap.data();
                const profile = { name: data.username, avatar: '👤' };
                userCache[uid] = profile;
                return profile;
            }
            const defaultProfile = { name: `User-${uid.substring(0, 5)}`, avatar: '👤' };
            userCache[uid] = defaultProfile;
            return defaultProfile;
        }


        // --- CORE CHAT LOGIC ---

        /** Updates the chat's lastReadMessageId for the current user. */
        async function updateReadReceipt(chatId, lastMessageId) {
            if (!currentUser || !chatId || !lastMessageId) return;

            const receiptRef = getReadReceiptDocRef(chatId, currentUser.uid);
            
            try {
                 await setDoc(receiptRef, {
                    lastReadMessageId: lastMessageId,
                    timestamp: serverTimestamp(),
                    userId: currentUser.uid,
                 }, { merge: true });
            } catch (error) {
                console.error("Error updating read receipt:", error);
            }
        }
        
        /** Sets up real-time listener for read receipts in the current chat. */
        function setupReadReceiptsListener(chatId) {
            if (readReceiptsUnsubscribe) readReceiptsUnsubscribe();
            
            const receiptsCollection = collection(db, `artifacts/${appId}/public/data/chats/${chatId}/readReceipts`);
            readReceiptsUnsubscribe = onSnapshot(receiptsCollection, (snapshot) => {
                const receipts = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.userId !== currentUser.uid) { // Only track others' receipts
                        receipts[data.userId] = data.lastReadMessageId;
                    }
                });
                currentChat.readReceipts = receipts; // Store receipts in currentChat object
                // Re-render messages to show new receipts instantly
                renderMessages(currentChat.messages || []); 
            }, (error) => {
                console.error("Error listening to read receipts:", error);
            });
        }


        /** Toggles the read receipt visualization overlay (Shift + R). */
        function toggleReadReceiptsView(isVisible) {
            showReadReceipts = isVisible;
            
            if (isVisible) {
                dom.readReceiptsInfo.textContent = '👁️ Read Receipts View ON (Shift + R)';
                dom.readReceiptsInfo.classList.remove('opacity-0');
            } else {
                dom.readReceiptsInfo.textContent = '👁️ Read Receipts View OFF (Shift + R)';
                // Fade out after a short delay
                setTimeout(() => dom.readReceiptsInfo.classList.add('opacity-0'), 1500); 
            }
            
            // Immediately show the new state for a moment before fading out
            dom.readReceiptsInfo.classList.remove('hidden');
            clearTimeout(dom.readReceiptsInfo.timer);
            dom.readReceiptsInfo.timer = setTimeout(() => {
                if (!showReadReceipts) {
                    dom.readReceiptsInfo.classList.add('hidden');
                }
            }, 3000);

            if (currentChatId) {
                 renderMessages(currentChat.messages || []); // Rerender to apply visual change
            }
        }

        /** Renders small read receipt avatars next to the last read message. */
        function renderReadReceipts(messageId) {
            if (!showReadReceipts || !currentChat || !currentChat.readReceipts) return '';

            let html = '';
            for (const userId in currentChat.readReceipts) {
                if (currentChat.readReceipts[userId] === messageId) {
                    const profile = userCache[userId] || { name: 'Unknown', avatar: '?' };
                    const isSender = messageId.startsWith(currentUser.uid); // Simple heuristic
                    const marginClass = isSender ? 'ml-1' : 'mr-1';
                    
                    html += `
                        <div class="read-receipt-avatar ${marginClass} bg-blue-500 text-white text-xs flex items-center justify-center float-right" title="${profile.name} read at this message">
                            ${profile.avatar}
                        </div>
                    `;
                }
            }
            return html;
        }

        /** Renders the list of attached images for the current message. */
        function renderAttachedImages() {
            if (attachedFiles.length === 0) {
                dom.imagePreviewContainer.classList.add('hidden');
                dom.imagePreviewContainer.innerHTML = '';
                return;
            }

            dom.imagePreviewContainer.classList.remove('hidden');
            dom.imagePreviewContainer.innerHTML = attachedFiles.map((file, index) => `
                <div class="relative w-20 h-20 rounded-lg overflow-hidden border border-gray-600">
                    <img src="${file.dataURL}" alt="Image preview ${index + 1}" class="w-full h-full object-cover">
                    <button type="button" data-index="${index}" class="remove-image-btn absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white w-5 h-5 rounded-full text-xs flex items-center justify-center shadow-md">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');

            // Add event listeners to remove buttons
            dom.imagePreviewContainer.querySelectorAll('.remove-image-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const index = parseInt(e.currentTarget.dataset.index);
                    attachedFiles.splice(index, 1);
                    renderAttachedImages();
                    updateCharLimitDisplay(); // Image count affects total message capacity indirectly
                });
            });
        }
        
        /** Handles file selection, compression, and updates the preview. */
        async function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            const imageLimit = currentChat.isGroup ? GROUP_IMAGE_LIMIT : PRIVATE_IMAGE_LIMIT;
            
            // Filter out already attached files and enforce limit
            const newFiles = files.slice(0, imageLimit - attachedFiles.length);
            if (newFiles.length === 0 && attachedFiles.length === imageLimit) {
                 showMessage(dom.addFriendMessage, `Maximum of ${imageLimit} images allowed.`, 'error');
                 return;
            }

            for (const file of newFiles) {
                if (!file.type.startsWith('image/')) {
                    showMessage(dom.addFriendMessage, `File ${file.name} is not an image.`, 'error');
                    continue;
                }
                
                try {
                    const dataURL = await fileToDataURL(file);
                    // Use standard compression for chat images
                    const compressedDataURL = await compressImage(dataURL, 800, 600, 0.8); 
                    
                    attachedFiles.push({
                        name: file.name,
                        dataURL: compressedDataURL, // Store the compressed base64
                        size: compressedDataURL.length,
                    });
                } catch (error) {
                    console.error("Error processing file:", error);
                    showMessage(dom.addFriendMessage, `Could not process image ${file.name}.`, 'error');
                }
            }
            
            renderAttachedImages();
            // Reset the input value so the same file can be selected again
            dom.fileUploadInput.value = ''; 
        }

        /** Updates the character limit display in the message input area. */
        function updateCharLimitDisplay() {
            if (!currentChat) return;

            const currentLength = dom.messageInput.value.length;
            const charLimit = currentChat.isGroup ? GROUP_CHAR_LIMIT : PRIVATE_CHAR_LIMIT;
            const remaining = charLimit - currentLength;
            
            dom.charLimitDisplay.textContent = formatLimit(remaining);
            
            if (remaining < 0) {
                dom.charLimitDisplay.classList.remove('text-gray-400');
                dom.charLimitDisplay.classList.add('text-red-400');
                dom.sendBtn.disabled = true;
            } else {
                dom.charLimitDisplay.classList.remove('text-red-400');
                dom.charLimitDisplay.classList.add('text-gray-400');
                dom.sendBtn.disabled = currentLength === 0 && attachedFiles.length === 0;
            }
        }


        /** Renders a single message item. */
        function renderMessage(message, isLast) {
            const isSender = message.senderId === currentUser.uid;
            const profile = userCache[message.senderId] || { name: 'Unknown', avatar: '?' };

            const time = message.timestamp?.toDate ? message.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '...';
            
            // Build the message HTML
            let messageHtml = `
                <div class="flex ${isSender ? 'justify-end' : 'justify-start'} group">
                    <!-- Sender Avatar/Info (Only for recipient messages and groups) -->
                    ${!isSender && currentChat.isGroup ? `
                        <div class="w-8 h-8 rounded-full flex items-center justify-center text-lg mr-2 mt-auto" title="${profile.name}">
                            ${profile.avatar}
                        </div>
                    ` : (currentChat.isGroup ? '<div class="w-8 h-8 mr-2"></div>' : '')}

                    <!-- Message Bubble -->
                    <div class="max-w-xs lg:max-w-lg flex flex-col ${isSender ? 'items-end' : 'items-start'}">
                        <div class="px-4 py-2 rounded-xl ${isSender ? 'bg-blue-600 text-white rounded-br-none' : 'bg-gray-700 text-gray-100 rounded-tl-none'} shadow-md">
                            ${!isSender && currentChat.isGroup ? `<p class="text-xs font-semibold mb-1 ${isSender ? 'text-blue-200' : 'text-blue-400'}">${profile.name}</p>` : ''}
                            
                            <!-- Attached Images -->
                            ${message.images && message.images.length > 0 ? `
                                <div class="grid grid-cols-2 gap-2 mb-2">
                                    ${message.images.map(img => `
                                        <img src="${img.dataURL}" alt="Attached Image" class="w-full h-auto rounded-lg cursor-zoom-in" loading="lazy">
                                    `).join('')}
                                </div>
                            ` : ''}

                            <!-- Message Text -->
                            <p class="whitespace-pre-wrap">${message.text || ''}</p>
                            <span class="text-xs mt-1 ${isSender ? 'text-blue-200' : 'text-gray-400'} block text-right">${time}</span>
                            
                            <!-- Read Receipts -->
                            ${isLast ? renderReadReceipts(message.id) : ''}
                        </div>
                    </div>
                </div>
            `;
            return messageHtml;
        }

        /** Renders all messages and updates the read receipt. */
        function renderMessages(messages) {
            currentChat.messages = messages; // Update the in-memory cache
            dom.messagesList.innerHTML = messages.map((m, index) => 
                renderMessage(m, index === messages.length - 1)
            ).join('');
            
            // Update read receipt for the last message
            if (messages.length > 0) {
                const lastMessage = messages[messages.length - 1];
                updateReadReceipt(currentChatId, lastMessage.id);
            }
            
            // Auto-scroll to bottom if the user is near the bottom
            scrollToBottom(false);
        }

        /** Sets up real-time listener for messages in the current chat. */
        function setupRealtimeChatListeners(chatId) {
            if (chatUnsubscribe) chatUnsubscribe();
            if (readReceiptsUnsubscribe) readReceiptsUnsubscribe();

            const messagesQuery = query(
                getMessagesCollectionRef(chatId),
                orderBy('timestamp'),
                // Only load the last 50 messages for initial load
                limit(50) 
            );

            chatUnsubscribe = onSnapshot(messagesQuery, async (snapshot) => {
                const messages = [];
                const newMessageIds = [];
                for (const change of snapshot.docChanges()) {
                    if (change.type === "added") {
                        const messageData = { ...change.doc.data(), id: change.doc.id };
                        // Ensure sender profile is cached before rendering
                        await fetchAndCacheUser(messageData.senderId);
                        messages.push(messageData);
                        newMessageIds.push(change.doc.id);
                    }
                }
                
                // Re-fetch all documents if not all loaded (e.g., if a previous document was modified)
                const allMessages = snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));
                await Promise.all(allMessages.map(m => fetchAndCacheUser(m.senderId)));
                renderMessages(allMessages);
            }, (error) => {
                console.error("Error listening to messages:", error);
            });
            
            setupReadReceiptsListener(chatId);
        }

        /** Opens the chat window for a given chat ID. */
        async function openChat(chatId, chatData) {
            if (chatId === currentChatId) return;

            currentChatId = chatId;
            currentChat = chatData;
            attachedFiles = [];
            renderAttachedImages();
            
            // Determine chat type and partner name
            const isGroup = Array.isArray(chatData.members);
            currentChat.isGroup = isGroup;

            if (isGroup) {
                dom.chatPartnerName.textContent = chatData.name || 'Group Chat';
                dom.chatTypeIndicator.textContent = 'Group';
                dom.chatTypeIndicator.classList.remove('hidden');
                dom.leaveGroupBtn.classList.remove('hidden');
            } else {
                const otherUid = chatData.members.find(uid => uid !== currentUser.uid);
                const otherUser = await fetchAndCacheUser(otherUid);
                dom.chatPartnerName.textContent = otherUser.name;
                dom.chatTypeIndicator.textContent = 'Private';
                dom.chatTypeIndicator.classList.remove('hidden');
                dom.leaveGroupBtn.classList.add('hidden');
            }
            
            // Toggle visibility for mobile layout
            dom.sidebar.classList.add('hidden', 'md:flex');
            dom.chatWindow.classList.remove('hidden');
            dom.unselectedPlaceholder.classList.add('hidden');

            setupRealtimeChatListeners(chatId);
            updateCharLimitDisplay();
        }

        /** Closes the current chat window. */
        function closeChat() {
            if (chatUnsubscribe) chatUnsubscribe();
            if (readReceiptsUnsubscribe) readReceiptsUnsubscribe();
            currentChatId = null;
            currentChat = null;
            attachedFiles = [];
            renderAttachedImages();
            dom.messagesList.innerHTML = '<p class="text-center text-gray-500">Select a contact to start chatting</p>';
            dom.chatPartnerName.textContent = 'Select a Chat';
            dom.chatTypeIndicator.classList.add('hidden');
            dom.leaveGroupBtn.classList.add('hidden');

            // Toggle visibility for mobile layout
            dom.sidebar.classList.remove('hidden', 'md:flex');
            dom.chatWindow.classList.add('hidden');
            dom.unselectedPlaceholder.classList.remove('hidden');
        }

        /** Sends a message to the current chat. */
        async function handleSendMessage(e) {
            e.preventDefault();
            if (!currentUser || !currentChatId) return;

            const messageText = dom.messageInput.value.trim();
            const charLimit = currentChat.isGroup ? GROUP_CHAR_LIMIT : PRIVATE_CHAR_LIMIT;

            if (messageText.length > charLimit) {
                showMessage(dom.addFriendMessage, `Message exceeds the ${formatLimit(charLimit)} character limit.`, 'error');
                return;
            }

            if (messageText === '' && attachedFiles.length === 0) return;

            // --- Group Chat Cooldown Check ---
            if (currentChat.isGroup) {
                if (isGroupChatCooldown) {
                    showMessage(dom.addFriendMessage, "Group chat message cooldown is active. Wait 2 seconds.", 'error');
                    return;
                }
                isGroupChatCooldown = true;
                setTimeout(() => { isGroupChatCooldown = false; }, GROUP_COOLDOWN_MS);
            }

            // --- Profanity Check (Group Chats Only) ---
            let textToSend = messageText;
            if (currentChat.isGroup) {
                const { isProfane, text: censoredText } = await checkProfanity(messageText);
                if (isProfane) {
                    // For group chats, we send the censored text, but alert the user.
                    // If the user wants to get rid of the censoring, they can use private chat.
                    textToSend = censoredText;
                    showMessage(dom.addFriendMessage, "Profanity detected. Message has been partially censored.", 'info');
                }
            }
            // Private chats have NO censoring.

            // Prepare images data
            const imagesToSend = attachedFiles.map(file => ({
                dataURL: file.dataURL,
                size: file.size,
                // Do not store the full file name for security/simplicity
            }));
            
            // The message object
            const message = {
                senderId: currentUser.uid,
                text: textToSend,
                timestamp: serverTimestamp(),
                images: imagesToSend,
            };

            // Clear input and attachments immediately
            dom.messageInput.value = '';
            attachedFiles = [];
            renderAttachedImages();
            updateCharLimitDisplay(); // Reset display

            try {
                await addDoc(getMessagesCollectionRef(currentChatId), message);
                // Reset cooldown visual if needed (optional)
            } catch (error) {
                console.error("Error sending message:", error);
                showMessage(dom.addFriendMessage, "Failed to send message.", 'error');
            }
        }
        
        // --- Contacts and Friend Logic ---
        
        /** Sets up real-time listener for user contacts (chats and requests). */
        function setupRealtimeContactListeners() {
            const profileRef = getUserProfileDocRef(currentUser.uid);
            onSnapshot(profileRef, (docSnap) => {
                if (docSnap.exists()) {
                    const profile = docSnap.data();
                    const chatIds = profile.contacts || [];
                    const requests = profile.friendRequests || [];
                    renderContactsList(chatIds, requests);
                }
            });
        }
        
        /** Renders the full list of chats and friend requests. */
        async function renderContactsList(chatIds, requests) {
            let html = '';
            
            // 1. Friend Requests (simplified to chat requests)
            if (requests.length > 0) {
                html += '<h3 class="text-sm font-semibold text-red-400 p-2">Requests:</h3>';
                for (const requesterId of requests) {
                    const requester = await fetchAndCacheUser(requesterId);
                    html += `
                        <div class="flex items-center justify-between p-3 border-b border-gray-700 hover:bg-gray-700 transition duration-150">
                            <span class="font-medium">${requester.name} (${requesterId.substring(0, 5)}...)</span>
                            <div class="space-x-2">
                                <button data-uid="${requesterId}" class="accept-request-btn text-green-400 hover:text-green-500"><i class="fas fa-check"></i></button>
                                <button data-uid="${requesterId}" class="reject-request-btn text-red-400 hover:text-red-500"><i class="fas fa-times"></i></button>
                            </div>
                        </div>
                    `;
                }
            }

            // 2. Chats (Private and Group)
            html += '<h3 class="text-sm font-semibold text-blue-400 p-2 mt-4">Chats:</h3>';
            
            if (chatIds.length === 0) {
                 html += '<p class="text-sm text-gray-500 p-2 text-center">No chats yet.</p>';
            } else {
                for (const chatId of chatIds) {
                    const chatRef = getChatDocRef(chatId);
                    const chatSnap = await getDoc(chatRef);
                    
                    if (chatSnap.exists()) {
                        const chatData = chatSnap.data();
                        const isGroup = Array.isArray(chatData.members) && chatData.members.length > 2;
                        
                        let chatName = chatData.name;
                        let chatIcon = isGroup ? '<i class="fas fa-users"></i>' : '<i class="fas fa-user"></i>';

                        if (!isGroup) {
                            const otherUid = chatData.members.find(uid => uid !== currentUser.uid);
                            const otherUser = await fetchAndCacheUser(otherUid);
                            chatName = otherUser.name;
                        }
                        
                        html += `
                            <div data-chat-id="${chatId}" class="chat-item flex items-center p-3 border-b border-gray-700 hover:bg-gray-700 transition duration-150 cursor-pointer rounded-lg">
                                <div class="text-xl mr-3 text-blue-300">${chatIcon}</div>
                                <div class="flex-grow">
                                    <span class="font-medium">${chatName}</span>
                                    <span class="block text-xs text-gray-400 truncate">${isGroup ? 'Group Chat' : 'Private Chat'}</span>
                                </div>
                            </div>
                        `;
                    }
                }
            }

            dom.contactsListEl.innerHTML = html;
        }


        // --- MODAL AND INTERACTION LOGIC ---

        /** Shows the general confirmation modal. */
        function showConfirmModal({ title, body, onConfirm }) {
            dom.confirmModalTitle.textContent = title;
            dom.confirmModalBody.textContent = body;
            
            // Clear previous listeners and attach new one
            dom.confirmModalConfirmBtn.onclick = () => {
                onConfirm();
                hideConfirmModal();
            };
            
            dom.confirmModal.classList.remove('hidden');
            setTimeout(() => dom.confirmModal.classList.remove('opacity-0'), 10);
        }

        /** Hides the general confirmation modal. */
        function hideConfirmModal() {
            dom.confirmModal.classList.add('opacity-0');
            setTimeout(() => dom.confirmModal.classList.add('hidden'), 300);
            dom.confirmModalConfirmBtn.onclick = null;
        }

        /** Handles friend request acceptance/rejection. */
        async function friendRequestLogic(otherUid, action) {
            const batch = writeBatch(db);
            const myProfileRef = getUserProfileDocRef(currentUser.uid);
            
            if (action === 'accept') {
                const newChatId = [currentUser.uid, otherUid].sort().join('_');
                
                // 1. Create the new chat document
                const chatRef = getChatDocRef(newChatId);
                batch.set(chatRef, {
                    name: 'Private Chat',
                    members: [currentUser.uid, otherUid],
                    createdAt: serverTimestamp(),
                    isGroup: false,
                }, { merge: true });

                // 2. Update my profile (remove request, add contact)
                batch.update(myProfileRef, {
                    friendRequests: arrayRemove(otherUid),
                    contacts: arrayUnion(newChatId),
                });
                
                // 3. Update other user's profile (add contact)
                batch.update(getUserProfileDocRef(otherUid), {
                    contacts: arrayUnion(newChatId),
                });

                showMessage(dom.addFriendMessage, `Chat with ${userCache[otherUid]?.name || otherUid} started!`, 'success');
            } else if (action === 'reject') {
                // Remove request from my profile
                batch.update(myProfileRef, {
                    friendRequests: arrayRemove(otherUid),
                });
                 showMessage(dom.addFriendMessage, `Request from ${userCache[otherUid]?.name || otherUid} rejected.`, 'success');
            }
            
            try {
                await batch.commit();
            } catch (error) {
                console.error(`Error handling ${action} request:`, error);
                showMessage(dom.addFriendMessage, `Failed to ${action} request.`, 'error');
            }
        }
        
        /** Handles the submission from the add contact modal. */
        async function handleAddContactSubmission() {
            const input = dom.friendIdInput.value.trim();
            if (!input) return;

            // Check if input is a valid UID (length 28)
            if (input.length === 28 && input !== currentUser.uid) {
                await handleSendFriendRequest(input);
            } else if (input.length >= 3 && input.length <= 50) {
                // Assume it's a group name if it's not a UID
                await handleCreateGroupChat(input);
            } else {
                 showMessage(dom.addFriendMessage, "Input must be a 28-character UID or a Group Name (3-50 chars).", 'error');
            }
        }

        /** Sends a friend/chat request to a UID. */
        async function handleSendFriendRequest(targetUid) {
             if (targetUid === currentUser.uid) {
                 showMessage(dom.addFriendMessage, "You cannot add yourself.", 'error');
                 return;
             }

             // Check if target is blocked by me
             const myProfileSnap = await getDoc(getUserProfileDocRef(currentUser.uid));
             if (myProfileSnap.exists() && myProfileSnap.data().blockedUsers?.includes(targetUid)) {
                  showMessage(dom.addFriendMessage, "You have blocked this user. Unblock them first.", 'error');
                  return;
             }
             
             // Check if I am blocked by target
             const targetProfileSnap = await getDoc(getUserProfileDocRef(targetUid));
             if (!targetProfileSnap.exists()) {
                 showMessage(dom.addFriendMessage, "User ID not found or account is not ready.", 'error');
                 return;
             }
             if (targetProfileSnap.data().blockedUsers?.includes(currentUser.uid)) {
                 showMessage(dom.addFriendMessage, "You are blocked by this user.", 'error');
                 return;
             }
             
             // Check if already in contact/requested
             const currentContacts = myProfileSnap.data().contacts || [];
             const potentialChatId = [currentUser.uid, targetUid].sort().join('_');
             if (currentContacts.includes(potentialChatId)) {
                 showMessage(dom.addFriendMessage, "You are already chatting with this user.", 'info');
                 return;
             }
             
             // Send request
             await updateDoc(getUserProfileDocRef(targetUid), {
                 friendRequests: arrayUnion(currentUser.uid)
             });
             showMessage(dom.addFriendMessage, "Friend request sent!", 'success');
        }
        
        /** Creates a new group chat. */
        async function handleCreateGroupChat(groupName) {
            try {
                const groupMembers = [currentUser.uid]; // Start with just the creator
                
                // 1. Create the new chat document in the chats collection
                const chatCollection = collection(db, `artifacts/${appId}/public/data/chats`);
                const newChatRef = await addDoc(chatCollection, {
                    name: groupName,
                    members: groupMembers,
                    createdAt: serverTimestamp(),
                    isGroup: true,
                    owner: currentUser.uid,
                });
                const newChatId = newChatRef.id;

                // 2. Add the new chat ID to the current user's profile
                await updateDoc(getUserProfileDocRef(currentUser.uid), {
                    contacts: arrayUnion(newChatId)
                });

                showMessage(dom.addFriendMessage, `Group chat "${groupName}" created!`, 'success');
                dom.friendIdInput.value = '';
                // The contact listener will automatically refresh the list
            } catch (error) {
                console.error("Error creating group chat:", error);
                showMessage(dom.addFriendMessage, "Failed to create group chat.", 'error');
            }
        }

        /** Handles clicking on the contacts list (to open chats or respond to requests). */
        function handleContactsListClick(e) {
            const chatItem = e.target.closest('.chat-item');
            if (chatItem) {
                const chatId = chatItem.dataset.chatId;
                // Find the chat data in the currently rendered list (assuming profile is up to date)
                const profileRef = getUserProfileDocRef(currentUser.uid);
                getDoc(profileRef).then(async (snap) => {
                    if (snap.exists()) {
                         const chatIds = snap.data().contacts || [];
                         if (chatIds.includes(chatId)) {
                             const chatSnap = await getDoc(getChatDocRef(chatId));
                             if (chatSnap.exists()) {
                                 openChat(chatId, chatSnap.data());
                             }
                         }
                    }
                });
                return;
            }

            const acceptBtn = e.target.closest('.accept-request-btn');
            const rejectBtn = e.target.closest('.reject-request-btn');

            if (acceptBtn) {
                friendRequestLogic(acceptBtn.dataset.uid, 'accept');
            } else if (rejectBtn) {
                friendRequestLogic(rejectBtn.dataset.uid, 'reject');
            }
        }

        // --- UI/UX & EVENT HANDLERS ---

        /** Scrolls the message container to the bottom. */
        function scrollToBottom(smooth = false) {
            if (dom.messagesContainer) {
                dom.messagesContainer.scrollTo({
                    top: dom.messagesContainer.scrollHeight,
                    behavior: smooth ? 'smooth' : 'auto'
                });
            }
        }

        /** Toggles the scroll-to-bottom button visibility. */
        function handleScroll() {
            if (!dom.messagesContainer) return;
            const scrollThreshold = 300; // Show button if 300px from bottom

            if (dom.messagesContainer.scrollHeight - dom.messagesContainer.scrollTop > dom.messagesContainer.clientHeight + scrollThreshold) {
                dom.scrollToBottomBtn.classList.remove('opacity-0', 'pointer-events-none');
            } else {
                dom.scrollToBottomBtn.classList.add('opacity-0', 'pointer-events-none');
            }
        }
        
        /** Toggles the theme (not fully implemented in this version but kept for structure). */
        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
        }

        /** Sets up all event listeners. */
        function setupEventListeners() {
            // General UI events
            dom.copyIdBtn.addEventListener('click', handleCopyId);
            dom.addContactBtn.addEventListener('click', () => {
                dom.addContactModal.classList.remove('hidden');
                setTimeout(() => dom.addContactModal.classList.remove('opacity-0'), 10);
            });
            dom.addContactCloseBtn.addEventListener('click', () => {
                dom.addContactModal.classList.add('opacity-0');
                setTimeout(() => dom.addContactModal.classList.add('hidden'), 300);
            });
            dom.submitAddContactBtn.addEventListener('click', handleAddContactSubmission);
            dom.confirmModalCancelBtn.addEventListener('click', hideConfirmModal);
            
            // Chat events
            dom.contactsListEl.addEventListener('click', handleContactsListClick);
            dom.backToContactsBtn.addEventListener('click', closeChat);
            dom.messageForm.addEventListener('submit', handleSendMessage);
            dom.messagesContainer.addEventListener('scroll', handleScroll);
            dom.scrollToBottomBtn.addEventListener('click', () => scrollToBottom(true));
            
            // File & Input Handling
            dom.attachFileBtn.addEventListener('click', () => dom.fileUploadInput.click());
            dom.fileUploadInput.addEventListener('change', handleFileSelect); 
            dom.messageInput.addEventListener('input', updateCharLimitDisplay);
            
            // Initial character limit display
            updateCharLimitDisplay();

            // Settings Modal
            dom.openSettingsBtn.addEventListener('click', () => {
                dom.settingsModal.classList.remove('hidden');
                setTimeout(() => dom.settingsModal.classList.remove('opacity-0'), 10);
                // Placeholder for blocked users render
                dom.blockedUsersList.innerHTML = '<p class="text-sm text-gray-400">Blocked user list management not fully copied in this scope.</p>';
            });

            dom.settingsModalCloseBtn.addEventListener('click', () => {
                dom.settingsModal.classList.add('opacity-0');
                setTimeout(() => dom.settingsModal.classList.add('hidden'), 300);
            });

            // Read Receipts Toggle (Shift + R)
            document.addEventListener('keydown', (e) => {
                // Check if Shift+R is pressed AND we are not focused on a text input/area
                if (e.key === 'R' && e.shiftKey && 
                    document.activeElement !== dom.messageInput && 
                    !dom.friendIdInput.contains(document.activeElement)) {
                    
                    e.preventDefault(); // Prevent default browser action
                    
                    if (currentChatId) {
                        toggleReadReceiptsView(!showReadReceipts);
                    } else {
                         showMessage(dom.addFriendMessage, "Open a chat to view read receipts.", 'info');
                    }
                }
            });

        }
        
        /** Handles copying the user's ID to the clipboard. */
        function handleCopyId() {
            const textToCopy = dom.myIdEl.textContent;
            const textArea = document.createElement("textarea");
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                dom.copyIdBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                setTimeout(() => { dom.copyIdBtn.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            } catch (err) {
                console.error('Fallback copy: ', err);
            }
            document.body.removeChild(textArea);
        }

        // --- START THE APP ---
        function main() {
            initFirebase();
            setupEventListeners();
        }
        
        main();
    </script>
</body>
</html>
